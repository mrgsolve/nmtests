!*********************************COPYRIGHT******************************************
!                                                                                   !
!       THE NONMEM SYSTEM MAY BE DISTRIBUTED ONLY BY ICON DEVELOPMENT               !
!       SOLUTIONS.                                                                  !
!                                                                                   !
!       COPYRIGHT BY ICON DEVELOPMENT SOLUTIONS                                     !
!       2009-2020 ALL RIGHTS RESERVED.                                              !
!                                                                                   !
!       DO NOT ATTEMPT TO MODIFY CODE WITHOUT FIRST CONSULTING WITH                 !
!       ICON DEVELOPMENT SOLUTIONS.                                                 !
!                                                                                   !
!************************************************************************************
!
!-----------------------------HISTORY------------------------------------------------
! VERSION     : NONMEM VII
! AUTHOR      : ALISON J. BOECKMANN
! CREATED ON  : JAN/1987
! LANGUAGE    : FORTRAN 90/95
! LAST UPDATE : JAN/1987 - ADD ICALL=4
!               AUG/1987 - CHANGE SIZE OF IDUMMY TO 51
!               OCT/1987 - FOR DELAYED DOSE RECORDS
!               FEB/1988 - ADD EVENT TYPE 4 (RESET AND DOSE)
!               JUL/1988 - RETURN G,H FOR NON-OBS; ALLOW NPEPS=0
!               APR/1990 - SECOND DERIVATIVES, LAG TIME
!               SEP/1990 - ALWAYS CALL PK, ERROR
!               DEC/1990 - FOR DELAYED DOSE RECORDS
!               FEB/1992 - FOR DELAYED DOSE RECORDS
!               JUL/1998 - THE FOLLOWING COMMON IS THE APPARENTLY BEST ONE CAN DO.
!               OCT/2007 - COMMON FOR INITIAL STEADY STATE
!               JUL/2008 - COMMON BLOCKS REPLACED WITH MODULES
!               NOV/2008 - INTRODUCED HEADER INFORMATIONS AND RESTRUCTURED AS PER
!                          THE NONMEM STANDARDS
!               JAN/2009 - ASSUMED SIZE ARRAY'S REPLACED WITH ASSUMED SHAPE
!               FEB/2009 - MOVED DATA STATEMENTS TO PRDATA.F90 FILE
!                        - BAYESIAN METHOD INCLUDED
!               APR/2009 - MOVED ERROR MESSAGES TO ERRORMSGS.F90 FILE AND
!                          IQUIT ADDED TO HANDLE ERROR MESSAGES
!               OCT/2009 - BUG FIX WHEN USING THE FEATURE "SS=2". ISSNOW CONDITION
!                          CHANGED FROM /=0 TO >=0
!               FEB/2010 - CHANGED SIZES TO PRSIZES
!               JUL/2010 - INCORPORATED 7.2BETA5.2B CHANGES
!               FEB/2011 - INTEGRATED 7.2BETA5.8B MODIFICATIONS
!               AUG/2012 - INTEGRATED NONMEM7.3ALPHA6.3 CHANGES
!               OCT/2012 - INTEGRATED NONMEM7.3BETA5.0 CHANGES
!               AUG/2013 - INTEGRATED NONMEM7.3a7.1 CHANGES
!               NOV/2016 - INTEGRATED NONMEM7.4 CHANGES
!               MAR/2019 - EMPIRICAL STEADY STATE ALGORITHM ADDED (TR ITEM 42)
!
!------------------------------------ PRED.F90 --------------------------------------
!
! SUBROUTINE PRED(ICALL,NEWIND,THETA,DATREC,INDXS,F,G,H)
!
! DESCRIPTION : This is PREDPP main program.
!               Provides prediction, partial derivatives of the statistical model with
!               respect to ETA and EPSILON random variables and stores them in the G
!               and H arguments of the PRED routine.
!
!               PRED is called many times, and when it is called, it is called in
!               bursts. During a burst of calls, the values in THETA are held fixed,
!               and the datarecords from an individual record are passed one after
!               the other in the order in which they appear in the individual record.
!               This is called a burst of the individual record.
!
!               PRED can be user defined subroutine and it may inturn call other
!               user supplied subroutines to accomplish various tasks.
!
!               There are a number of PRED initializations. The first one occurs at
!               the beginning of the NONMEM run and allows PRED computations to be
!               initialized over all problems. This is signalled to PRED with ICALL=0.
!               The other PRED initializations follow, one occuring at the beginning
!               of each problem. These are signalled to PRED with ICALL=1.
!
!               At a PRED initialization all the data can also be transgenerated.
!               There also exist PRED finalizations, special calls to PRED enabling
!               computations in the routine to be finalized. Such computations could
!               produce output not generated by NONMEM itself. There is one PRED
!               finalization at the end of each problem. These calls are signalled to
!               PRED with ICALL=3. At a PRED finalization the first data record of the
!               data set is passed in DATREC, but the values in THETA are the final
!               estimates.
!
! ARGUMENTS   : ICALL,NEWIND,THETA,DATREC,INDXS,F,G,H
!               IN     - ICALL,NEWIND,THETA
!                        ICALL  - -1 = PRED has been called for PRED_IGNORE_DATA purposes
!                                     at the beginning of data file input; one such call
!                                     per input file.
!                        ICALL  - 0 = PRED has been called for initialization purposes
!                                     at the beginning of the NONMEM run; one such call
!                                     per run. DATREC contains the firstdata record.
!                                     THETA contains the initial estimates. PRED need
!                                     not compute F, G, or H.
!                                 1 = PRED has been called for problem initialization
!                                     purposes at the beginning of a NONMEM problem; one
!                                     such call per problem. Otherwise, identical to ICALL=0.
!                                 2 = For the data record contained in DATREC, PRED
!                                     has been called for the purpose of computing F,
!                                     the value of the prediction,and/or the values of
!                                     other PRED-defined items, appropriate for the record.
!                                     PRED should compute F, and also G and H as appropriate.
!                                     THETA contains the values to be used to compute F.
!                                     With conditional estimation, to obtain ETA values,
!                                     PRED should call GETETA. This is a routine call. Returns
!                                     F  and G.
!                                 3 = PRED has been called for problem finalization
!                                     purposes at the end of a NONMEM problem; one such
!                                     call per (sub)problem. DATEC contains the first data
!                                     record. THETA contains the final estimates. Otherwise,
!                                     identical to ICALL=0.
!                                 4 = For the data record contained in DATREC, PRED has
!                                     been called during the Simulation Step for the
!                                     purpose of computing a value of the dependent variable
!                                     and, possibly, values of independent variables,
!                                     appropriate for the record. PRED should compute F
!                                     (the value of the dependent variable). THETA
!                                     contains the initial estimates,which are the values
!                                     to be used to compute F. PRED should call SIMETA
!                                     (and SIMEPS) to obtain simulated values of ETA (and EPS).
!                                 5 = For the data record contained in DATREC,PRED has been
!                                     called for the purpose of computing the expectation
!                                     of the PRED item andpossibly, the expectations of
!                                     other PRED-defined items,appropriate for the record.
!                                     Such a call occurs when the marginal data item (MRG_)
!                                     is defined in the data set and has a non-zerovalue for
!                                     the data record in question. If the MRG_ data item on
!                                     the record has the value 1 or 2, the value returned by
!                                     PRED in F contributes to the expectation of the PRED item.
!                                     Similarly,the values returned in other PRED-defined
!                                     items contribute toexpectations of these items.
!                                     THETA contains the final estimates.The expectations
!                                     in question are over possible values of ETA,and
!                                     to obtain ETA values, PRED should call GETETA.
!                                 6 = PRED has been called for the purpose of computing
!                                     the rawdata average of the DV data items and,
!                                     possibly, the raw data averages of PRED-defined
!                                     items. Such a call occurs when the raw-data data
!                                     item (RAW_) is defined in the data set and has
!                                     a non-zero value for a template data record.
!                                     The value of the DV data item in the data record
!                                     contained in DATREC will be included in the raw
!                                     data average of the DV data items. However, when
!                                     the raw data average corresponding to the label
!                                     DV in a table or scatterplot is to be different from
!                                     the raw data average of the DV items themselves,
!                                     PRED may recompute the value of DV. PRED may
!                                     return a value of 1 in F to omit the DV item in the
!                                     data record from the average.
!                       NEWIND  - 0 = First record of the data set. THETA value may
!                                     differ from value at last call with this record.
!                                 1 = First record of the data set, THETA value does
!                                     not differ from value at last call with this
!                                     record, and PRED is nonrecursive. First record
!                                     of a subsequent individual record.
!                                 2 = The record is the second or subsequent record of
!                                     an individual record.
!                        THETA  - A one-dimensional NONMEM THETA vector in which
!                                 the values of the THETA's are passed.
!               OUT    - NONE
!               IN OUT - DATREC,INDXS,F,G,H
!                        DATREC - A one-dimensional array in which the current
!                                 data  record is passed
!                        INDXS  - The values specified in the $INDEX record of the
!                                 NM-TRAN control stream.
!                        F      - When ICALL=2, the prediction IS associated with the data
!                                 record. With oddtype data, the likelihood of the observation
!                                 in the record, but if there is no observation, F is ignored.
!                                 When ICALL=4, the value of the simulated observation is
!                                 associated with the data record. Alternatively, F can
!                                 be ignored, and the DV item in the data record can be
!                                 directly set to the value of the simulated observation.
!                                 With odd-type data, F is ignored; PRED should directly
!                                 set the DV item to the value of the simulated observation.
!                        G      - An array of derivatives of F with respect to etas. Values
!                                 should be set when ICALL=2.
!                                 G(i,1) is the partial derivative of F w.r.t eta(i). When
!                                 the data are population, G(i,j+1) is the second partial
!                                 derivative of F with respect to eta(i), ETA(j) (lower-
!                                 triangular; j=1,..., i).
!                                 Second derivatives are needed only when the Laplacian
!                                 method is used to estimate parameters.
!                        H      - An array of partial derivatives of F w.r.t epsilons.
!                                 When the data are population, values should be set when
!                                 ICALL=2.
!                                 H(i,1) is the derivative of F with respect to EPS(i).
!                                 H(i,j+1) is the partial derivative of H(i,1) with respect
!                                 to ETA(j). These mixed second derivatives are needed only
!                                 when the INTERACTION option is used to estimate parameters.
!
!                                 REFERENCES: Guide I, section C.2 (p. 12)
!                                 REFERENCES: Guide IV, section III.B.8 (p. 24), IV (p. 44)
!                                 REFERENCES: Guide V, section 12.3 (p. 133)
!
! CALLED BY   : CKPRDE,COMMRG,COMPR,FINAL,INITL,INLOBJ,NP4F,OBJ,OBJ2,OBJ3,OBPRB,OS,PRRES,
!               SIGLCOV_SETUP,SIGLCOV_DONE,SIML,(EVENT_REPEAT)
!
! CALLS       : PREDI     - Initialization-Finalization routine of PRED
!               PK        - Obtain values for basic (rate constants) and additional
!                           (compartment scale parameters, dose-related parameters
!                           such as modeled infusion rates) pharmacokinetic parameters.
!               TRANS     - Translates (or transforms) the values for a set of basic PK
!                           parameters modeled. If a suitable translator is not found
!                           in the Library, the user may write his own.
!               SADVAN2   - Calls SADVAN under normal circumstances.
!                           EM algorithms may redirect for efficiency purposes
!               SSS       - Supervisor of steady state
!               ERROR     - The ERROR subroutine is called by PREDPP to model
!                           intra-individual error in observed values.
!               ERRORMSGS - Writes error messages to a file JUNIT and sets IQUIT to 1 indicating
!                           that NONMEM has to quit for non-super problems. And for super problems
!                           calculation continues with next sub problem
!                           G2,GG,IF,PREDI_SETTOL,EVENT_REPEAT,PREDI,PRED_TIMEVALUES_INFO,
!                           ERRORMSGS,PK,TRANS,SADVAN2,SSS,ERROR,DAT1
!
! ALGORITHM   : - Find K based on ICALL to take values from 0 to 3 and
!                 branch accordingly
!               - If K = 1,4, must pass first DATREC
!                 - Call Init.-termination module of PRED - Call PREDI
!               - If K = 2, ICALL not 2:  Model initialization or termination
!                 - When ICALL=1, must pass first physical DATREC
!                 - Call Init.-termination module of PRED - Call PREDI
!               - If K = 3, ICALL=2 Normal entry
!                 - Set NEWIF flag unless IPS is 2
!                 - Initialize for first individual record
!                 - Initialize for new individual or reset (event ID 3 or 4)
!                 - Initialize status vector, state vector, and derivatives
!                 - Initialize vectors for PK compartment initialization
!                 - Initialize delayed dose array
!                 - Initialize model event time array
!                 - Zero out all model event time indicator variables
!                 - Execute in-line subroutine to create looping scheme for ADVAN6,8, and SS6
!                   - First check if largest ETA will fit by itself
!                   - If user says, make separate calls to DVERK for each ETA's seconds
!                   - Find optimal packing; Use logic of COMPK5, not COMPK2
!               - Copy THETA to THETAS
!               - Initialize infusion arrays
!               - Check if the call data item exists
!               - For delayed dose records
!                 - Check for old delayed doses which might require intermed. advance
!                 - Begin code for additional doses
!                 - Check for delayed additional dose before new time point
!                 - End delayed dose records
!               - Restore ETA derivatives to original positions in case A used in PK
!               - Get phamacokinetic parameters - Call PK
!               - Branch if user initializes A_0 in PK
!               - Convert any PK params that are modelled as logs
!               - Convert derivatives of all ETA's
!               - Translate GG if necessary
!               - Return from call PK with delayed dose
!               - Clear old indicator variables.
!               - Restore most recent old indicator variable then, get indices of those that are
!                 between T1 and T2
!               - Set base of those that are at earlier time
!               - Restore base of those that are at same time
!               - Get compartment number
!               - Allow 100 as the default output compartment
!               - If DELTA > 0 or DTIME, no zero-out. CAll SADVAN2
!               - If LAGDOS is true, save position in infusion arrays. Else,
!                 - Allow SS=3 (Like 1, but use existing amounts as initial estimates)
!                 - Zero out all compartments
!                 - Turn off any delayed dose records
!                 - Set all infusions off
!               - Add in SS doses to state vector
!               - If this is initialization to SS, then nothing else need be done (cannot be lagged).
!                 Go back and process the event record.
!               - Steady-state with lag time;  Advance to correct point in cycle
!               - For Type 2 Steady state with absorption lag: Add prior system contents
!                 - Restore position in infusion arrays
!               - Compute F for the appropriate compartment
!               - Compute second derivatives of F wrt ETA(J),ETA(KK)
!               - Decide whether to call ERROR subroutine
!               - Restore ETA derivatives to original positions in case used in ERROR
!               - PREDI sets YMULT=1.0
!               - Use XNPETA rather than NPETAS in case IFRSTDER=0
!               - Branch according to event type
!               - Turn off any delayed dose records for this compartment
!               - Turn any infusions off
!               - Duration and Rate are modelled
!               - End of EVENT record processing
!               - Reach here for ADVAN6,8,9 or any ADVAN with SS=6, if ADVAN/SS called
!                 - Create new delayed dose
!                 - Initialize the MNEXT array only when first needed
!               - Get next model event time
!               - Case 1 - Both MCNTR and MTCNTR > 0
!                 - With LE, makes LAGTIME stops preceded MTIME stops when both are =
!                 - With LT, MTIME stop precedes LAGTIME stop when ALAG=MTIME
!               - Case 2 - Only delayed doses
!               - Case 3 - Only model event times
!               - Set model event time spikes
!               - Advance to time of next additional dose
!               - Call PK with delayed dose
!               - Return from call PK with delayed dose
!               - Execute code block if DT or any of its derivatives is non-zero.
!               - Add instantaneous dose to state vector
!               - Zero-order absorbed dose (infusion)
!               - Use next available slot in inf. arrays
!               - Model duration and rate and update dose
!               - Change spikes into basis
!               - Sort the model event times for call PK at non-event time (this happens after
!                 the original stop)
!               - Return here from sort the model event times
!               - Expand DAETA to correct positions for error
!               - Copy amnt after call to PK for the A0 feature
!               - Reinitialize infusion counters
!               - RETURN
!
! MODULES USED: FSIZES,PRSIZES,PRDATA,PRDIMS,PRRADAR5U,PRDDESLVU,SIZES,NMPRD_INT,
!               PRCM_INT,PRCOM_INT,PRMOD_INT,PROCM_INT,ROCM_INT,NM_BAYES_INT,
!               NMBAYES_INT,CMNM2_INT,PRCM_LOG,PRCOM_LOG,NMPRD_REAL,PRCOM_REAL,
!               PRMOD_REAL,PROCM_REAL,NMBAYES_REAL,NMPRD_CHAR,NM_INTERFACE,
!               PR_INTERFACE
!
! CONTAINS    : NONE
!
! LOCALS      : PALZ=MAX(PAL,PCT+20),I,IC,ICF,ICTRAN,IEVENT,II,IMOVE,IRET,ISCALE,
!               ITEMP,J,JJ,K,KE,KEND,KETA,KF,KK,LACTIV,LNCM1,MHEAD,MIC,MICALL,MIP,
!               MSAVE,NEWIF=0,NN,PD1,U,EVREPEAT,EVNUMBER,ALLOC_FLAG=0,NWW,NWW2,IPREV,
!               NEVENTPREV=-1,NEVENTPREV2=-1,AFLGUP=-1,MCMT,MLAG,MNBR,MTOLD,IDEF,
!               AMOUNT,DSUM,METIME,MINTIM,MSTART,OLDA,RATE,T1,T2,TMIN,DSUM2,DSUM3,
!               DSUM0,NOTDEFINED,SSTOL,SSATOL,DJMORE,DPREV,FIRST_JTIME,FIRST_JMORE,
!               FIRST_JMORE2,FIRST_JDELTA,FIRST_JTIME2,TSTATEP=-1.0D+300,MNEXT,MTIME,
!               OLDAET,OLDS,AMNTO,DMTIME,DOLDS,OLD2AE,SAVDOS,D2OLDS,CTEMP,WK132,
!               AZERO,DDSTOP,DELAY,DIDCAL,DOSE,EXTRST,ISSTIM,LAGDOS,MDTIME,MESTOP,
!               MSAME,OBSERV,ODTIME,OTHER,SSDOSE
!
!---------------------------- END OF HEADER -----------------------------------------
!
      SUBROUTINE PRED(ICALL,NEWIND,THETA,DATREC,INDXS,F,G,H)
!
      USE FSIZES,       ONLY: F_LTH
!
      USE PRSIZES,      ONLY: ISIZE,DPSIZE,PC,PAL,PCT,PD,PE,MAXIC,PES
!
      USE PRDATA,       ONLY: AVAL,EVAL,PVAL
!
      USE PRDIMS,       ONLY: GPRD,HPRD,GERD,HERD,GPKD,GTRD
!
      USE PRRADAR5U,    ONLY: RADAR5NM_RESUME
!
      USE PRDDESLVU,    ONLY: DDERESUMENM
!
!
! INTEGER
      USE NMPRD_INT,    ONLY: COMACT,IDXIDDUM,IERPRD,IFRSTDER,IPS,IQUIT,ISECDER,     &
                              LVOUT,NAETA,NDI,NETEXT,MDVRES
      USE PRCM_INT,     ONLY: MFLAG1,MFLAG2,MFLAG3,MFLAG4,MFLAG6,MFLAG7,NBRON,SLEND, &
                              SLOOP,SLST,SPW,SS3,XNBRON,XNCM1,INRD,IANRD
      USE PRCOM_INT,    ONLY: ADVID,BETA,CALLA9,CALLER,CALLID,CALLPK,CPYTHE,IBACK,   &
                              IBF,ID,IDC,IDO,IERRA,IFORM,IFR,IHEAD,IINST,ILAG,IMAX,  &
                              IMT,IMTBEG,IMTEND,IMTGG,INEXT,INTFLG,IP,IPKA,IPKA0,    &
                              IPOOL,IREV,IRGG,IS,ISV,ITRANS,ITSC,IXUSER,JAMT,JCOMPF, &
                              JCOMPT,JCONT,JDELTA,JDUM,JERROR,JEVENT,JMORE,JRATE,JSS,&
                              JTIME,MAXKF,MCNTR,METH,MITER,MMAX,MTCNTR,MTNO,MTPTR,NC,&
                              NP,NPEPS,NPETAS,SSC,SSID,SV,XNPETA,YFORM,LOGUNT
      USE PRMOD_INT,    ONLY: I_SS,ICALLD,ISSMOD,ISSNOW,MTDIFF
      USE PROCM_INT,    ONLY: A_0FLG,IDXETA,IDXETAI,ISFINL,MTNEXT,MTNOW,MTPAST,NACTIV,NEVENT,&
                              PNEWIF,A_UFLG
      USE ROCM_INT,     ONLY: NDATINDR
      USE NM_BAYES_INT, ONLY: TOLTOPRED,DATNN_PREV,DATNN_PREVM
      USE NMBAYES_INT,  ONLY: PREDADDL_ON
      USE CMNM2_INT,    ONLY: IRECIDX
! LOGICAL
      USE PRCM_LOG,     ONLY: CALL9,CALLE,CALLP,DIDAES,DIDCAA,DIDDES,DOFINL,GENMOD,  &
                              TIMDEF
      USE PRCOM_LOG,    ONLY: DTIME,LFLAG,NEWWAY,NOETAS,SECOND,XNOETA,DTSTART,DTEND
! REAL
      USE NMPRD_REAL,   ONLY: EPS,ETA,PASSRC
      USE PRCOM_REAL,   ONLY: D2DELT,D2TSTA,DDELTA,DELTA,DTSTAR,G3,HH,I2AEA,I2DEA,   &
                              I2REA,IA,IAA,IAEA,IDA,IDEA,IRA,IREA,ONE,TSTART,XD,XR,  &
                              YMULT,ZERO
      USE PRMOD_REAL,   ONLY: A_0,DA_0,D2A_0
      USE PROCM_REAL,   ONLY: AMNT,D2AETA,D2DOST,DAETA,DDOST,DOSREC,DOSTIM,EVTREC,   &
                              THETAS,TSTATE
      USE NMBAYES_REAL, ONLY: ADDL_ACTUAL,ADDL_TIMEDIFF,ADDL_TIME
! CHARACTER
      USE NMPRD_CHAR,   ONLY: ETEXT
! INTERFACE
      USE NM_INTERFACE, ONLY: ERRORMSGS
      USE PR_INTERFACE, ONLY: ERROR,PREDI,PK,TRANS,SADVAN2
!
      IMPLICIT NONE
!
! Since IDEF, a global variable is defined as 1D and 2D array in two different routines.
! So COMMON is retained.
!      COMMON /PRCOMI/ IDEF
      INTEGER(KIND=ISIZE), INTENT(IN)     :: ICALL,NEWIND
      INTEGER(KIND=ISIZE), INTENT(IN OUT) :: INDXS(*)
      REAL(KIND=DPSIZE),   INTENT(IN)     :: THETA(*)
      REAL(KIND=DPSIZE),   INTENT(IN OUT) :: DATREC(*),F,G(GPRD,*),H(HPRD,*)
!
      INTEGER(KIND=ISIZE), EXTERNAL :: EVENT_REPEAT
!
!------------------------------------------------------------------------------------
!
! Local Variables
!
      INTEGER(KIND=ISIZE), PARAMETER :: PALZ=MAX(PAL,PCT+20)
      INTEGER(KIND=ISIZE) :: I,IC,ICF,ICTRAN,IEVENT,IF,II,IMOVE,IRET,ISCALE,ITEMP,J, &
                             JJ,K,KE,KEND,KETA,KF,KK,LACTIV,LNCM1,MHEAD,MIC,MICALL,  &
                             MIP,MSAVE,NEWIF=0,NN,PD1,U,EVREPEAT,EVNUMBER,           &
                             ALLOC_FLAG=0,NWW,NWW2,IPREV,NEVENTPREV=-1,              &
                             NEVENTPREV2=-1,AFLGUP=-1
      INTEGER(KIND=ISIZE), DIMENSION(PALZ) :: MCMT,MLAG,MNBR
      INTEGER(KIND=ISIZE), DIMENSION(PCT)  :: MTOLD
      INTEGER(KIND=ISIZE), DIMENSION(7,MAX(PC,5)) :: IDEF
      REAL(KIND=DPSIZE) :: AMOUNT,DSUM,G2,GG,METIME,MINTIM,MSTART,OLDA,RATE,T1,T2,   &
                           TMIN,DSUM2,DSUM3,DSUM0,NOTDEFINED,SSTOL,SSATOL,DJMORE,    &
                           DPREV,FIRST_JTIME,FIRST_JMORE,FIRST_JMORE2,FIRST_JDELTA,  &
                           FIRST_JTIME2,TSTATEP=-1.0D+300
      REAL(KIND=DPSIZE), DIMENSION(PALZ)      :: MNEXT,MTIME
      REAL(KIND=DPSIZE), DIMENSION(PE)        :: OLDAET
      REAL(KIND=DPSIZE), DIMENSION(PC)        :: OLDS,AMNTO
      REAL(KIND=DPSIZE), DIMENSION(PALZ,PE)   :: DMTIME
      REAL(KIND=DPSIZE), DIMENSION(PC,PE)     :: DOLDS
      REAL(KIND=DPSIZE), DIMENSION(PE,PE)     :: OLD2AE
      REAL(KIND=DPSIZE), DIMENSION(PD+1,PALZ) :: SAVDOS
      REAL(KIND=DPSIZE), DIMENSION(PALZ,PE,PE):: D2MTIM   
      REAL(KIND=DPSIZE), DIMENSION(PC,PE,PE)  :: D2OLDS
      CHARACTER(LEN=4)    :: CTEMP
      CHARACTER(LEN=132)  :: WK132
      LOGICAL :: AZERO,DDSTOP,DELAY,DIDCAL,DOSE,EXTRST,ISSTIM,LAGDOS,MDTIME,MESTOP,  &
                         MSAME,OBSERV,ODTIME,OTHER,SSDOSE
!
      SAVE
      DATA TMIN /-100.0D+00/
!
!------------------------------------------------------------------------------------
!     COMMON /NMPRD1/ IERPRD,NETEXT
!     COMMON /NMPRD2/ ETEXT(3)
!     INTEGER IERPRD,NETEXT
!     CHARACTER*132 ETEXT
!     COMMON /ROCM29/ IPS
!     INTEGER IPS
!     COMMON /ROCM32/ NIREC,NDREC
!     INTEGER NIREC,NDREC
!     COMMON /CM5/ IDUM1,IXPRED,IDXIDDUM(51),IDAT,IDUM2(6)
!     COMMON /CM5/ IC0501(3),IC0502(21)
!     INTEGER IC0501,IC0502
!     COMMON /ROCM12/ ISECDER,IFRSTDER
!     INTEGER ISECDER,IFRSTDER
!     COMMON /ROCM15/ NRETA,LVOUT(PE)
!     INTEGER NRETA,LVOUT
!     INTEGER NPETAS,NPEPS,NEVENT,IDXIDDUM,IDUM1,IXPRED,IDUM2
!     COMMON /NMPRD7/ ETA(PE),EPS(PE)
!     DOUBLE PRECISION ETA,EPS
!     COMMON /NMPRD3/ COMACT,COMSAV
!     INTEGER COMACT,COMSAV
!     DIMENSION THETA(*),DATREC(*),INDXS(*),G(PE,*),H(PE,*)
!     DOUBLE PRECISION THETA,F,G,H
!     INTEGER ICALL,NEWIND,INDXS
!     DOUBLE PRECISION DATREC
!     COMMON /PRCOM0/ NP,NBP,YFORM
!     COMMON /PRCOM0/ MAXKF,IFORM
!     COMMON /PRCOM0/ IDC,IDO,MAXIC,ISV,IINST,ITURN
!     COMMON /PRCOM0/ JTIME,JCONT,JEVENT,JAMT,JRATE,JSS,JDELTA
!     COMMON /PRCOM0/ JCOMPT,JCOMPF,JERROR,SSC,KREC,JMORE,JDUM
!     COMMON /PRCOM1/ NOETAS,SECOND
!     COMMON /PRCOM2/ IBF,IRR,IS,ID,ITSC,IFR,ILAG
!     COMMON /PRCOM3/ ITRANS,IRGG,IREV,NPETAS,NPEPS
!     COMMON /PRCOM4/ G3,HH,DELTA,DT,DTE
!     COMMON /PRCOM4/ YMULT,ZERO,ONE,XR,XD,TSTART,DTSTAR
!     COMMON /PRCOM4/ DDELTA,D2DELT,ADTE,D2ADTE
!     COMMON /PRCOM5/ ISPEC,DCTR,BETA,DD
!     COMMON /PRCOM5/ IP,IPOOL,IHEAD,INEXT,IBACK,SV
!     COMMON /PRCOM6/ IA,IAA,IAEA,IRA,IREA,IDA,IDEA,R,RE
!     COMMON /PRCOM6/ RHO,RHOE,SDEL,SDELE,SSA,SSAE,SSR,SSRE
!     COMMON /PRCOM6/ SAMT,SDEL1
!     COMMON /PRCOM6/ I2AEA,I2REA,I2DEA,R2E,D2DTE,D2TSTA
!     COMMON /PRCOM7/ ADVID,SSID
!     COMMON /PROCM6/ THETAS(LTH)
!     COMMON /PROCM7/ EVTREC(5,PD+1),N
!     DOUBLE PRECISION EVTREC
!     DOUBLE PRECISION THETAS
!     COMMON /PRCOMI/ IXUSER,IDEF,XNPETA,XNOETA
!     COMMON /PRCOMN/ LOGUNT,NC
!     INTEGER IXUSER,IDEF(7,PC),XNPETA
!     LOGICAL XNOETA
!     COMMON /PRDDE1/ICALLD,IDEFD(2),IDEFA(2)
!     INTEGER ICALLD,IDEFD,IDEFA
!     DOUBLE PRECISION DELTA,G3,HH
!     DOUBLE PRECISION SDELE,RHOE,SSAE,SSRE,YMULT,ZERO,XR,XD
!     DOUBLE PRECISION ONE,TSTART,DTSTAR(PE)
!     DOUBLE PRECISION DDELTA(PE),D2DELT(PE,PE),ADTE(PE),D2ADTE(PE,PE)
!     DOUBLE PRECISION IA(90),IAA(90),IAEA(90,PE),IRA(90),IDA(90)
!     DOUBLE PRECISION IREA(90,PE),IDEA(90,PE),R(PC),RE(PC,PE)
!     DOUBLE PRECISION I2REA(90,PE,PE),I2DEA(90,PE,PE),I2AEA(90,PE,PE)
!     DOUBLE PRECISION R2E(PC,PE,PE),D2DTE(PE,PE)
!     DOUBLE PRECISION D2TSTA(PE,PE)
!     DOUBLE PRECISION DT,DTE(PE),RHO,SDEL,SSA,SSR
!     DOUBLE PRECISION SAMT,SDEL1
!     DIMENSION SDELE(PE),RHOE(PE),SSAE(PE),SSRE(PE)
!     DIMENSION G3(PG+1,PE+1,PE+1),HH(PE,PE)
!     INTEGER LOGUNT,IRGG,IREV,ITRANS
!     INTEGER NEVENT ! NPETAS,NPEPS,
!     INTEGER JCONT,JTIME,JEVENT,JAMT,JRATE,JSS,JDELTA
!     INTEGER JCOMPT,JCOMPF,JERROR
!     INTEGER NC,IDC,IDO,NP,NBP,SSC,KREC,JMORE,JDUM
!     INTEGER ISV(PC),IBF(PC),IRR(PC),SV(PC)
!     INTEGER IINST(PC),ITURN(PC),ITSC,IFR,ILAG(PC),IS(PC),ID(PC)
!     INTEGER ADVID,SSID,MAXKF,IFORM(PG+1),YFORM,MAXIC
!     INTEGER BETA(90),IPOOL(90),IP,IHEAD,INEXT(90),IBACK(90)
!     INTEGER ISPEC,DD(90),DCTR
!     LOGICAL NOETAS,SECOND
!     COMMON /PRCMX1/ GENMOD,MAPPED,COMPAC
!     LOGICAL GENMOD,MAPPED,COMPAC
!     COMMON /PRCMX2/ XNC,XNCM1,MAP,MAPINV,NBRON,XNBRON
!     INTEGER XNC,XNCM1,MAP(PC),MAPINV(PC),NBRON,XNBRON
!     COMMON /PROCM2/ DOSTIM,DDOST,D2DOST
!     DOUBLE PRECISION DOSTIM
!     DOUBLE PRECISION DDOST(PE),D2DOST(PE,PE)
!     COMMON /PROCM3/ DOSREC
!     DOUBLE PRECISION DOSREC(PD)
!     COMMON /PRCOMM/ MMAX,MCNTR
!     INTEGER MMAX,MCNTR
!     DOUBLE PRECISION MTIME(PAL)
!     INTEGER MNBR(PAL),MCMT(PAL),MLAG(PAL)
!     DOUBLE PRECISION MINTIM
!     DOUBLE PRECISION MNEXT(PAL)
!     DOUBLE PRECISION DMTIME(PAL,PE),D2MTIM(PAL,PE,PE)
!     INTEGER MSAVE,MIC
!     COMMON /PRCOMG/ MITER,METH,IMAX,ISTFLG,INTFLG
!     INTEGER MITER,METH,IMAX,ISTFLG,INTFLG
!     COMMON /PROCM1/ PNEWIF
!     INTEGER PNEWIF
!     COMMON /PRCOMT/ DTIME,LFLAG,DTDER
!     LOGICAL DTIME,LFLAG,DTDER
!     COMMON /PROCM4/ A,DAETA,D2AETA
!     DOUBLE PRECISION A,DAETA,D2AETA
!     DIMENSION A(PC),DAETA(PC,PE),D2AETA(PC,PE,PE)
!     COMMON /PROCM9/ TSTATE
!     DOUBLE PRECISION TSTATE
!     COMMON /PROCMB/ ISFINL
!     INTEGER ISFINL
!     COMMON /PRCMLX/ MFLAG1,MFLAG2,MFLAG3,MFLAG4,MFLAG5,MFLAG6
!     COMMON /PRCMLX/ MFLAG7,MFLAG8,SS3
!     COMMON /PROCMC/ A_0FLG
!     INTEGER A_0FLG
!     INTEGER MFLAG1,MFLAG2,MFLAG3,MFLAG4,MFLAG5,MFLAG6
!     INTEGER MFLAG7,MFLAG8,SS3
!     COMMON /PRCOMU/ NEWWAY
!     LOGICAL NEWWAY
!     COMMON /PRCOMA/ IERRA,IPKA0,IPKA
!     INTEGER IERRA,IPKA0,IPKA
!     COMMON /PRCMET/ LST,LEND,SLEND(PE),SLST(PE),SPW,SLOOP
!     INTEGER LST,LEND,SLEND,SLST,SPW,SLOOP
!     COMMON /PROCM5/ NACTIV,M(0:PE)
!     INTEGER NACTIV,M
!     COMMON /PRCOMC/ CALLER,CALLPK,CALLID,CALLA9,CPYTHE
!     INTEGER CALLER,CALLPK,CALLID,CALLA9,CPYTHE
!     COMMON /PRCM01/ CALLP,CALLE,CALL9,TIMDEF
!     LOGICAL CALLP,CALLE,CALL9,TIMDEF
!     COMMON /PRCM03/ DIDCAA,DIDDES,DIDAES,DOFINL
!     LOGICAL DIDCAA,DIDDES,DIDAES,DOFINL
!     COMMON /PRCOMJ/ MTNO,IMTBEG,IMTEND,IMTGG,IMT,MTCNTR,MTPTR
!     INTEGER MTNO,IMTBEG,IMTEND,IMTGG(PCT),IMT(PCT),MTCNTR,MTPTR
!     COMMON /PROCMA/ MTNOW,MTPAST,MTNEXT
!     INTEGER MTNOW,MTPAST(0:PCT),MTNEXT(0:PCT)
!     COMMON /PRDPK2/ MTDIFF
!     INTEGER MTDIFF
!     COMMON /PRDPK3/ A_0,DA_0,D2A_0
!     DOUBLE PRECISION A_0,DA_0,D2A_0
!     DIMENSION A_0(PC),DA_0(PC,PE),D2A_0(PC,PE,PE)
!     COMMON /PRDPK4/ I_SS,ISSNOW,ISSMOD
!     INTEGER I_SS,ISSNOW,ISSMOD
      G2(I,J,K)=G3(I,IDXETA(J)+1,IDXETA(K)+1) ! Statement function
      GG(I,J)=G3(I,IDXETA(J-1)+1,1)
!
! Changed code for ICALL=4. Same as ICALL=2.
! SADVAN and ADVANS see 2, but users PK,ERROR,TRANS see 4
!
! PD: Columns in DATREC (Not currently a NONMEM parameter)
!
! PREDPP used to keep track of KREC, the no. of the data record.
! This was used prior to NONMEM IV for error messages from PREDPP.
! It actually serves no purpose in NONMEM IV because NONMEM issues
! The error messages, but i did not realize that it could be omitted.
! I've done it now. It didn't work with repeat feature and wasted time.

! GENMOD true for general ADVAN (Set by PREDI)
! XNC,XNCM1,XNBRON are original values of NC,NCM1,NBRON (Set by PREDI)
! NBRON tells how many compartments are now ON (Not counting output)
! Mapped is true when a mapping in effect (Set by SADVAN, SSS)
! MAP, MAPINV: Maps 'REAL' compartment nos. to 'Reduced set' and V.V.
!
! A_0FLG:1 When start of IR or reset (For PK). Otherwise 0
! Map active ETAS: M(K) is "REAL" index of K-th. active ETA
!
! Flags describing external events:
! MFLAG1: 1 when start of IR or reset has occurred
! MFLAG2: 1 When call to PK has occurred
! MFLAG3: 1 when a new bolus dose was added to state vector
! MFLAG4: 1 when an infusion was started
! MFLAG5: 1 when an infusion has ended (internal to ADVAN9)
! MFLAG6: 1 when status vector changed (compt ON)
! MFLAG7: 1 when status vector changed (compt OFF)
! MFLAG8: 1 when steady state is being computed
!
! NPETAS = Number of ETAs
! NPEPS  = Number of EPSILONs
!
! Model-definition variables:
! NC  = Number of primary compartments
! IDC = Index of default compartment for dose
! IDO = Index of default compartment for observation
!
! Vectors:
! SV  = Status vector (0=OFF,1=ON)
! ISV = Initial status vector (0=OFF,1=ON) (from SADVAN)
! IS  = Index of scaling parameter
! IINST = 1: Dose ok; IINST=0: Dose not allowed
! ITURN = 1: Compt. may be turned OFF; ITURN=0: Compt. always ON
! IBF = Index of bio-availability param. for doses
! IRR = Index of rate parameter for zero-order absorbed doses
! ID  = Index of duration parameter for zero-order absorbed doses
! ITSC= Index of time scale parameter
!
! PK variables:
! NBP = Number of basic pharmacokinetic parameters
! NP  = Total pharmacokinetic parameters
!
! Infusion variables:
! MAXIC  = Maximum number of infusions at one time
! IA(IF) = Dose rate field of datrec which set up this infusion
! IAA(IF)= Remaining amount
! IDA(IF)= Remaining duration
! IRA(IF)= Current rate
! IDEA(IF,K) = Partial deriv. of IDA(IF) wrt ETA(K)
! IAEA(IF,K) = Partial deriv. of IAA(IF) wrt ETA(K)
! IREA(IF,K) = Partial deriv. of IRA(IF) wrt ETA(K)
!
! IDAT = Number of data record items
! IFLAG nonmem flag. When 9999, only one individual in data
!
! Internal flags
! ITRANS = Translator flag (0=NOCALL, 1=CALL)
! NEWIF  = Internal new individual flag (2=same ind., 1=new)
!
! RJB nm75a7 1/29/2019
! Replaced use of ZERO with NOTDEFINED in appropriate locations regarding MNEXT() and MINTIM
! With the allowance of negative time, MNEXT()=ZERO is a legitimate value
      NOTDEFINED=-1.0D+300
      IF (ALLOC_FLAG == 0) THEN
        IF (.NOT. ALLOCATED(THETAS)) ALLOCATE(THETAS(F_LTH))
        ALLOC_FLAG=1
      END IF

      IF(ICALL==0.AND.TOLTOPRED==1) THEN ! introduced nonmem7.4
        LOGUNT=2050
        CALL PREDI_SETTOL()
        GO TO 999
      ENDIF
!
      GPKD=PE
      GERD=GPRD
      HERD=PES
      GTRD=PE
      IF(ICALL>=0) EVREPEAT=EVENT_REPEAT(0,1,ICALL) !7.2
      EVNUMBER=0 !7.2
!
 1500 CONTINUE !7.2
      AMNTO(1:NC)=0.0D+00
      EVNUMBER=EVNUMBER+1 !7.2
      PD1=PD+1
      MICALL=ICALL
      IF (ICALL >= 4) MICALL=2
      K=MICALL+1
!
      SELECT CASE (K)
      CASE (0,1,4)
        NEVENT=1
        CALL PREDI(ICALL,NEWIND,THETA,INDXS,F,H,IDEF)   ! Call Init.-termination module of PRED
        IF (IQUIT /= 1) THEN
          LACTIV=0; LNCM1=0
          IF (IERPRD > 0) GO TO 998
        END IF
        GO TO 999
      CASE (2)    ! ICALL not 2:  Model initialization or termination
        SSTOL=0.1D0**INRD(0)
        IF(IANRD(0)>ZERO) THEN
          SSATOL=0.1D0**IANRD(0)
        ELSE
          SSATOL=1.0D-12
        ENDIF
        NEVENT=1  ! When ICALL=1, must pass first physical DATREC
        EVTREC(1,1:NDI)=DATREC(1:NDI)
        NEVENTPREV=0
        NEVENTPREV2=0
        EVREPEAT=EVENT_REPEAT(1,1,ICALL) !7.2
        PNEWIF=NEWIND
        CALL PREDI(ICALL,NEWIND,THETA,INDXS,F,H,IDEF)   ! Call Init.-termination module of PRED
        NEVENT=1
        IF (IQUIT /= 1) THEN
          LACTIV=0; LNCM1=0
          IF (IERPRD > 0) GO TO 998
        END IF
        IF (EVENT_REPEAT(2,NEVENT,ICALL) /= 0) GO TO 1500 !7.2
        GO TO 999
      CASE (3)    ! ICALL=2 Normal entry
        IF(ADDL_TIMEDIFF/=0.0D+0) THEN
          IF(DATREC(JEVENT)==3.0D+00.OR.DATREC(JEVENT)==4.0D+00) THEN
            ADDL_TIMEDIFF=0.0D+00
            ADDL_TIME=DATREC(JTIME)
            ADDL_ACTUAL=0.0D+00
            RADAR5NM_RESUME=0
            IF(DDERESUMENM/=0) DDERESUMENM=10
          ENDIF
        ENDIF
        IF (NEWIND /= 2) THEN
          NEVENTPREV=0
          NEVENTPREV2=0
          ADDL_TIMEDIFF=0.0D+00
          ADDL_ACTUAL=0.0D+00
          ADDL_TIME=DATREC(JTIME)
          DTSTART=.FALSE.
          DTEND=.FALSE.
          J=IDXIDDUM(1)
          NEVENT=0
          NOETAS = XNOETA .OR. IFRSTDER == 0
          SECOND = ISECDER == 1
! ABJ How can PREDPP know when that has happened?
! MSAME is true when the mapping of ETAS is 1-1 (ETAS that are off have the highest nos.)
          NAETA=0
          DO I=1,XNPETA
            IF (LVOUT(I) == 1) NAETA=NAETA+1
          END DO
          IF (NOETAS) THEN
            NPETAS=0
            NACTIV=0 !7.2B51B
            MSAME=.TRUE.
            IDXETAI(0:XNPETA)=0
          ELSE
            MSAME=.TRUE.
            NPETAS=XNPETA-NAETA
            IDXETA(0)=0
            IDXETAI(0)=0
            NACTIV=0
            DO I=1,XNPETA
              IDXETAI(I)=0
              IF (LVOUT(I) == 1) CYCLE
              NACTIV=NACTIV+1
              IDXETA(NACTIV)=I
              IDXETAI(I)=NACTIV
              IF (NACTIV /= I) MSAME=.FALSE.
            END DO
          END IF
!
          IF (NEWIND == 1) THEN
            IF (IPS /= 2) NEWIF=1   ! Set NEWIF flag unless IPS is 2
          ELSE                      ! Initialize for first individual record
            ICALLD=ICALL
            NEWIF=1
            IF (XNOETA) THEN
              ETA(1:NPEPS)=ZERO
            ELSE
              EPS(1:NPEPS)=ZERO
            END IF
          END IF
          IF(NEWIF==1) THEN
            RADAR5NM_RESUME=0
            IF(DDERESUMENM/=0) DDERESUMENM=10
          ENDIF
          IF(ADVID==16 .OR. ADVID==17.OR. ADVID==18) CALL PRED_TIMEVALUES_INFO()
        END IF
        NEVENTPREV=0
        NEVENTPREV2=0
        NEVENT=NEVENT+1
        IF (NEVENT > 5) NEVENT=5
        EVTREC(NEVENT,1:NDI)=DATREC(1:NDI)
        ADDL_TIME=DATREC(JTIME)+ADDL_TIMEDIFF
!        IF(JTIME>0.AND.PREDADDL_ON/=0.AND.ADDL_TIMEDIFF/=0.0D+00) DATREC(JTIME)=DATREC(JTIME)+ADDL_TIMEDIFF
!        IF(JTIME>0.AND.PREDADDL_ON/=0.AND.ADDL_TIMEDIFF/=0.0D+00) EVTREC(NEVENT,JTIME)=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF
        EVREPEAT=EVENT_REPEAT(1,NEVENT,ICALL) !7.2
        IF (NEVENT == 1) PNEWIF=NEWIND
        IF (EVTREC(NEVENT,JCONT) /= 0) THEN
          F=ZERO        ! No need to zero out G,H before returning - NONMEM did it
!          IF (EVENT_REPEAT(2,NEVENT,ICALL) /= 0) GO TO 1500 !7.2
          GO TO 999
        END IF
!
        AZERO=.FALSE.   ! Complete EVTREC received. Now start processing it.
        IF (IPKA0 == 1) THEN    ! Initialize vectors for PK compartment initialization
          A_0(1:NC)=ZERO
          DA_0(1:NC,1:XNPETA)=ZERO
          IF (SECOND) THEN
            DO KK=1,XNPETA
              DO J=KK,XNPETA
                D2A_0(1:NC,J,KK)=ZERO
              END DO
            END DO
          END IF
        END IF
        IF (NEWIF == 2 .AND. EVTREC(NEVENT,JEVENT) < 3) GO TO 2100
! Initialize for new individual or reset (event ID 3 or 4)
! Code for ISSNOW (initialize steady state) Added 10/2007
        ISSTIM=.TRUE.
        ISSNOW=0
        IF (NEWIF == 1) THEN
          T1=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF
          TMIN=T1
          METH=-1; MITER=-1
          IMAX=-1; INTFLG=-1
          DIDDES=.FALSE.; ISSTIM=.TRUE.
          DIDAES=.FALSE.; ISSNOW=ISSMOD
        END IF
! Set ISSNOW for reset or reset and dose
        IF (EVTREC(NEVENT,JEVENT) == 3 .OR. EVTREC(NEVENT,JEVENT) == 4) THEN
          ISSTIM=.TRUE.
          ISSNOW=ISSMOD
        END IF
! Initialize status vector, state vector, and derivatives
! Use XNPETA instead of NPETAS just to make it look good when IFRSTDER=0
        AZERO=.TRUE.
        SV(1:NC)=ISV(1:NC)
        AMNT(1:NC)=ZERO
        DAETA(1:NC,1:XNPETA)=ZERO
        IF (SECOND) THEN
          DO KK=1,XNPETA
            DO J=KK,XNPETA
              D2AETA(1:NC,J,KK)=ZERO
            END DO
          END DO
        END IF
!
!
        TSTATE=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF
        A_0FLG=1
        NBRON=XNBRON
        DIDCAL=.FALSE.
!
        MCNTR=0         ! Initialize delayed dose array
        DDSTOP=.FALSE.
!
        MTNOW=0         ! Initialize model event time array
        MESTOP=.FALSE.
!
        IF (IMTBEG > 0) THEN
          MTDIFF=0; J=IMTEND-IMTBEG+1  ! Zero out all model event time indicator variables
          MTCNTR=0; MTPAST(1:J)=0
          MTPTR=-1; MTNEXT(1:J)=0
        END IF
!
        IF (.NOT. GENMOD .AND. SSID /= 6) GO TO 2040
        MFLAG1=1        ! Reset record must force initialization for LSODI1 before next advance
!
        IF (SECOND .AND. (ADVID == 6 .OR. ADVID == 8 .OR. ADVID==13 .OR. ADVID==14 &
          .OR. ADVID==16.OR. ADVID==18  .OR. SSID == 6)) THEN
! In-line subroutine to create looping scheme for ADVAN6,8, and SS6
          IF (LACTIV /= NACTIV .OR. LNCM1 /= XNCM1) THEN
            LACTIV=NACTIV
            LNCM1=XNCM1
! U tell how many multiples of XNCM1 are needed to do the seconds
! First check if largest ETA will fit by itself
            U=1+2*NPETAS
            IF (U*XNCM1 > SPW) THEN
              ETEXT(2)='WORK ARRAYS ARE TOO SMALL FOR 2ND. DERIVS.'
              ETEXT(3)='INCREASE PPW, OR DECREASE NO. OF. COMPTS AND/OR ETAS, OR USE DERIV2=NO'
              IERPRD=2
              GO TO 998
            END IF
!
            IF (INTFLG /= -1) THEN  ! If user says: separate calls to DVERK for each ETA's seconds
              FORALL (SLOOP=1:NACTIV)
                SLST(SLOOP)=SLOOP
                SLEND(SLOOP)=SLOOP
              END FORALL
              SLOOP=NACTIV
            ELSE                    ! Find optimal packing; Use logic of COMPK5, not COMPK2
              SLOOP=0
              KETA=1
              KEND=NACTIV
              GO TO 7020
            END IF
          END IF
        END IF
      CASE DEFAULT
        CALL ERRORMSGS(306) ! ' ERROR IN PRED ROUTINE. VARIABLE "K" IS NOT IN THE RANGE (1-4)'
        GO TO 999
      END SELECT
!
 7999 IF (CPYTHE > 0) THETAS(1:CPYTHE)=THETA(1:CPYTHE)    ! Copy THETA to THETAS?
!
 2040 DO WHILE (IHEAD /= 0)     ! Initialize infusion arrays
        IPOOL(IP)=IHEAD
        IP=IP-1
        IHEAD=INEXT(IHEAD)
      END DO
!
 2100 CONTINUE !7.2
      T2=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF   ! New or same individual
      TSTART=T1
      LFLAG=.FALSE.             ! Fix bug in T with LAGTIME
      DELTA=T2-T1
!
      IF (ADVID == 9 .OR. ADVID==15 .OR. ADVID==17) THEN      ! CALLA, CALLE, CALLP initialized by PREDI at ICALL=1
        IF (TIMDEF) THEN        ! If time is defined, don't do anything special for ADVAN9
          CALL9=.FALSE.
        ELSE                    ! If time is not defined, CALLFL= EVERY EVENT (0) or once per IR
          CALL9=CALLA9 == -1 .OR. NEWIF == 1
        END IF
      ELSE
        CALL9=.FALSE.
      END IF
!
      IF (JERROR /= JDUM) THEN ! Check if the call data item exists
        CALLE=.FALSE.
        CALLP=.FALSE.
        I=EVTREC(NEVENT,JERROR)
        IF (I /= 0) THEN
          IF (AVAL(I) == 1) CALL9=.TRUE.
          IF (EVAL(I) == 1) CALLE=.TRUE.
          IF (PVAL(I) == 1) CALLP=.TRUE.
        END IF
      END IF
!*** For delayed dose records ****
! Check for old delayed doses which might require intermed. advance
      IF (MCNTR > 0 .OR. MTCNTR > 0) THEN
!*** Begin code for additional doses ******
! Check for delayed additional dose before new time point
        IF (DELTA /= 0 .AND. EVTREC(NEVENT,JSS) /= 1 .AND. EVTREC(NEVENT,JSS) /= 3) THEN
          DIDCAL=.FALSE.; GO TO 6005
        END IF
      END IF !*** End delayed dose records
!
! CALLPK: 1=ALL, 2=FIRST or TIME CHANGE, 3=Once per indiv
 6900 IF (CALLPK /= 1 .AND. NEWIF == 2 .AND.                                     &
        (DELTA <= ZERO .OR. CALLPK /= 2) .AND. .NOT. CALLP) GO TO 2200
!
! Get phamacokinetic parameters
! There is a branch here from the delayed dose code when DOSTIM>0 and CALLID=1 (CALL with
! delayed dose); also first time when CALLID=0 (will then return to 2200)
!
! Use XNPETA instead of NPETAS in case IFRSTDER=0 - Don't want old values left behind
!
 2109 G3(1:NP,0+1:XNPETA+1,1)=ZERO
!
      IF (SECOND) THEN
        DO KK=1,XNPETA
          DO J=KK,XNPETA
            G3(1:NP,J+1,KK+1)=ZERO
          END DO
        END DO
      END IF
!
      MFLAG2=1; MTDIFF=0; IRET=1 ! Restore ETA derivatives to original positions in case A used in PK
!
      IF (NAETA /= 0 .AND. NEWIND == 2) GO TO 8000
 8003 CONTINUE
      CALL PK(ICALL,IDEF,THETA,IREV,EVTREC,NEVENT,INDXS(IXUSER),IRGG,G3,XNPETA)
      NEVENTPREV=NEVENT+5
      EVTREC(NEVENTPREV,1:NDI)=EVTREC(NEVENT,1:NDI)

!
      IF (IQUIT == 1) GO TO 999
      IF (IERPRD > 0) GO TO 998
!
 8004 IF (IPKA0 == 1) GO TO 8500    ! Branch if user initializes A_0 in PK
      A_0FLG=0
! Added 10/2007; Allow PK to set I_SS. If not, no error: same as I_SS=0
 8501 IF (I_SS /= -1) THEN
        IF (I_SS < 0 .OR. I_SS > 3) THEN
          ETEXT(2)='PK SUBROUTINE HAS GIVEN I_SS A VALUE THAT IS NOT 0, 1, 2, OR 3.'
          IERPRD=1; GO TO 998
        END IF
        IF (ISSTIM .AND. I_SS /= -1) ISSNOW=I_SS
      END IF
! Convert any PK params that are modelled as logs
! Convert derivatives for all ETAs, not just the active ones
      IF (MAXKF /= 0) THEN
        DO KF=1,MAXKF
          ITEMP=IFORM(KF)
          G3(ITEMP,1,1)=EXP(GG(ITEMP,1))
          IF (SECOND) THEN
            DO KK=1,XNPETA
              DO J=KK,XNPETA
                G3(ITEMP,J+1,KK+1) = GG(ITEMP,1)*(G3(ITEMP,KK+1,1)*G3(ITEMP,J+1,1)   &
                  +G3(ITEMP,J+1,KK+1))
              END DO
            END DO
          END IF
          DO KE=1,XNPETA
            G3(ITEMP,KE+1,1)=GG(ITEMP,1)*G3(ITEMP,KE+1,1)
          END DO
        END DO
      END IF
! Translate GG if necessary
! Don't pass ICALL directly. A user TRANS might change it 12/96
      IF (ITRANS /= 9999) THEN
        ICTRAN=ICALL
        CALL TRANS(ICTRAN,IRGG,G3,XNPETA)
        IF (IERPRD > 0) GO TO 998
      END IF
!
      IF (DELAY) THEN   ! Return from call PK with delayed dose
        DIDCAL=.TRUE.
        DELAY=.FALSE.
        GO TO 6019
      END IF
! The following "IF" was moved here on 4/2001.
! In its original location, it prevented a second call to PK with event record (when
! EVENT TIME = DOSTIM or EVENT TIME = MTIME). Now, the second call occurs, but the
! MTIME info. is not rechecked. AJB
! The following avoids changing base/spik when next advance has DELTA 0
      IF ((DIDCAL .AND. DELTA == 0) .OR. (MTNO == 0) .OR.              &
        (MTPTR >= 0 .AND. NEWIF == 2 .AND. MTDIFF == 0)) GO TO 2200
! Sort the model event times for call PK with event records
      EXTRST=.FALSE.
! Comes here also from code after updating the dose (after the original stop).
! First, clear old indicator variables.
 1000 MTOLD(1:MTNO)=MTPAST(1:MTNO)
      MTPAST(1:MTNO)=0
! Restore most recent old indicator variable then, get indices of those that are between T1 and T2
      MTCNTR=0
!
      IF (MTPTR == -1) THEN
!       MSTART=0    ! BUG FIX AJB 11/2015
        ! Some datasets may not start with time=0
        MSTART=TMIN
      ELSE
        MSTART=TSTART
      END IF
!
      DO K=1,MTNO
        IMT(K)=K
        IF (GG(IMTBEG+K-1,1) < MSTART) THEN  ! Set base of those that are at earlier time
          MTPAST(K)=1; CYCLE
        END IF
        IF (GG(IMTBEG+K-1,1) == MSTART) THEN ! Restore base of those that are at same time
          IF (MTPTR <= 1) THEN               ! Look only at time if this is first sort
            MTPAST(K)=1; CYCLE
          END IF
          IF (MTOLD(K) == 1) THEN            ! Look at old base if this is subsequent sort
            MTPAST(K)=1; CYCLE
          END IF
        END IF
        MTCNTR=MTCNTR+1
        IMTGG(MTCNTR)=IMTBEG+K-1
        IMT(MTCNTR)=K
      END DO
!
      IF (MTCNTR > 1) THEN
        DO K=2,MTCNTR
          IMOVE=0
          DO II=K,MTCNTR
            JJ=MTCNTR-II+K
            IF (GG(IMTGG(JJ-1),1) <= GG(IMTGG(JJ),1)) CYCLE
            IMOVE=1
            ITEMP=IMTGG(JJ)
            IMTGG(JJ)=IMTGG(JJ-1)
            IMTGG(JJ-1)=ITEMP
            ITEMP=IMT(JJ)
            IMT(JJ)=IMT(JJ-1)
            IMT(JJ-1)=ITEMP
          END DO
          IF (IMOVE == 0) EXIT ! Finished if no moves (array is in sort)
        END DO
      END IF
!
      MTPTR=1
      IF (MTCNTR == 0) MTPTR=0
      IF (EXTRST) GO TO 6801
! The delayed dose code returns here if PK need not be called again
 2200 CONTINUE
      IEVENT=EVTREC(NEVENT,JEVENT)
      OBSERV=IEVENT == 0
      DOSE=IEVENT == 1 .OR. IEVENT == 4
      OTHER=IEVENT == 2 .OR. IEVENT == 3
      SSDOSE=(DOSE .AND. EVTREC(NEVENT,JSS) > 0.0) .OR. ISSNOW > 0
      IC=EVTREC(NEVENT,JCOMPT) ! Get compartment number
!
      IF (IC <= 0) THEN
        IF (IC == 0) IC=IDC
        IF (IC < 0)  IC=-IC
        IF (IC == 0) THEN
          LAGDOS=.FALSE.
          GO TO 2500
        END IF
      END IF
!
      IF (IC == 1000) IC=NC               ! Always allow 1000 as the default output cmt 3/2013
      IF (IC == 100 .AND. NC < 100) IC=NC ! Allow 100 as the default output cmt if small model 3/2103
!
      IF (ILAG(IC) /= 0) THEN
        LAGDOS = DOSE .AND. GG(ILAG(IC),1) /= 0
      ELSE
        LAGDOS=.FALSE.
      END IF
!
      IF (.NOT. SSDOSE) GO TO 2500
!
      IF (GG(ITSC,1) == ZERO) GO TO 9007 ! Steady state dose
      SS3=0
!
      IF (EVTREC(NEVENT,JSS) == 2 .OR. ISSNOW == 2) THEN
        IF (DELTA > ZERO .OR. DTIME) THEN ! No zero-out
! Bauer.  SADVAN2->SADVAN under normal circumstances.  EM algorithms may redirect for efficiency purposes
          CALL SADVAN2(MICALL)
          IF (IERPRD > 0) GO TO 998
        END IF
        IF (LAGDOS) THEN
          OLDS(1:NC)=AMNT(1:NC) ! Type 2 Steady state with absorption lag:  Must save state vector etc
          AMNT(1:NC)=ZERO
          IF (NPETAS /= 0) THEN !7.2B51B
            DOLDS(1:NC,1:NPETAS)=DAETA(1:NC,1:NPETAS)
            DAETA(1:NC,1:NPETAS)=ZERO
            IF (SECOND) THEN !7.2B51B
              DO I=1,NC
                DO K=1,NPETAS
                  DO J=K,NPETAS
                    D2OLDS(I,J,K)=D2AETA(I,J,K)
                    D2AETA(I,J,K)=ZERO
                  END DO
                END DO
              END DO
            END IF
          END IF !7,2B51B
          MHEAD=IHEAD ! Save position in infusion arrays
          IHEAD=0
          MIP=IP+1
          MDTIME=DTIME
        END IF
      ELSE      ! Allow SS=3 (Like 1, but use existing amounts as initial estimates)
        IF ((ISSNOW == 3 .OR. EVTREC(NEVENT,JSS) == 3) .AND. &
          (SSID == 6 .OR. SSID == 9 .OR. SSID==13 .OR. SSID==14 .OR. SSID==15 &
          .OR. SSID==16 .OR. SSID==17 .OR. SSID==18)) THEN
          SS3=1
        ELSE    ! Zero out all compartments
          AMNT(1:NC)=ZERO
          IF (NPETAS /= 0) THEN !7.2B51B
            DAETA(1:NC,1:NPETAS)=ZERO
            IF (SECOND) THEN
              DO KK=1,NPETAS
                DO J=KK,NPETAS
                  D2AETA(1:NC,J,KK)=ZERO
                END DO
              END DO
            END IF
          END IF !7.2B51B
        END IF
        MCNTR=0                 ! Turn of any delayed dose records
        DO WHILE (IHEAD /= 0)   ! Set all infusions off
          IPOOL(IP)=IHEAD
          IP=IP-1
          IHEAD=INEXT(IHEAD)
        END DO
      END IF
!
      IF (GENMOD .AND. SV(IC) == 0) THEN ! Now add in SS doses to state vector
        NBRON=NBRON+1
        MFLAG6=1                         ! This was not in NONMEM IV; added 9/95
      END IF
!
      SV(IC)=1; SSC=IC
!      IF(ADVID==16 .OR. ADVID==17) CALL PRED_TIMEVALUES_INFO()
      CALL SSS
      IF (IQUIT == 1) GO TO 999
      ISSTIM=.FALSE.
!
      IF (IERPRD > 0) GO TO 998
! Added 10/2007
! If this is initialization to SS, then nothing else need be done (cannot be lagged).
! Go back and process the event record.
!      IF (ISSNOW /= 0) THEN
      IF (ISSNOW > 0) THEN !7.1.1
        ISSNOW=0; GO TO 2200
      END IF
!
      TSTATE=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF
      IF (.NOT. LAGDOS) GO TO 2700
! Steady-state with lag time;  Advance to correct point in cycle
      DELTA=EVTREC(NEVENT,JDELTA)-GG(ILAG(IC),1)
!
      IF (DELTA <= ZERO) THEN
        IF (EVTREC(NEVENT,JAMT) == 0) THEN
          ETEXT(2)='PK PARAMETER FOR ABSORPTION LAG IS NOT ZERO FOR STEADY STATE INFUSION'
        ELSE
          ETEXT(2)='PK PARAMETER FOR ABSORPTION LAG IS GREATER THAN OR EQUAL TO STEADY STATE'
          ETEXT(3)='DOSE INTERVAL'
        END IF
      END IF
!
      DSUM=ZERO
      DTIME=.FALSE.
!
      IF (.NOT. NOETAS) THEN
        DO K=1,NPETAS
          DDELTA(K)=-GG(ILAG(IC),K+1)
          DSUM=DSUM+ABS(DDELTA(K))
        END DO
        IF (SECOND) THEN
          DO K=1,NPETAS
            DO J=K,NPETAS
              D2DELT(J,K)=-G2(ILAG(IC),J,K)
              DSUM=DSUM+ABS(D2DELT(J,K))
            END DO
          END DO
        END IF
      END IF
!
      DTIME=DSUM /= ZERO
! Bauer. SADVAN2->SADVAN under normal circumstances.  EM algorithms may redirect for efficiency purposes
      CALL SADVAN2(MICALL)
      IF (IERPRD > 0) GO TO 998
!
      MFLAG1=1        ! Needed if ADVAN9 - next call to ADVAN will be back in time
      DTIME=.FALSE.
! Type 2 Steady state with absorption lag: Add prior system contents
      IF (EVTREC(NEVENT,JSS) == 2) THEN
        AMNT(1:NC)=AMNT(1:NC)+OLDS(1:NC)
        FORALL (I=1:NC,K=1:NPETAS) DAETA(I,K)=DAETA(I,K)+DOLDS(I,K)
        DO I=1,NC
          IF (SECOND) THEN
            DO K=1,NPETAS
              DO J=K,NPETAS
                D2AETA(I,J,K)=D2AETA(I,J,K)+D2OLDS(I,J,K)
              END DO
            END DO
          END IF
        END DO
!
        IF (MHEAD /= 0) THEN        ! Restore position in infusion arrays
          IF (IHEAD /= 0) THEN
            INEXT(IPOOL(MIP))=MHEAD
            IBACK(MHEAD)=IPOOL(MIP)
          ELSE
            IHEAD=MHEAD
          END IF
        END IF
        DTIME=MDTIME
      END IF
!
      GO TO 2700
! Not a steady state dose (OBSERV,OTHER,NON-SS DOSE)
 2500 IF ((IEVENT < 3 .OR. CALL9) .AND. (DELTA > ZERO .OR. DTIME .OR. CALL9)) THEN
        IF (GG(ITSC,1) == ZERO) GO TO 9007
        IF (IFR == IRGG .OR. SV(NC) == 0) THEN
! Bauer.  SADVAN2->SADVAN under normal circumstances.  EM algorithms may redirect for efficiency purposes
          CALL SADVAN2(MICALL) ! No output compartment fraction or output compartment is off
          IF (IERPRD > 0) GO TO 998
        ELSE ! Dose event, not steady state
          IF (GG(IFR,1) < ZERO) GO TO 9102 ! Output compartment fraction in effect
          IF (GG(IFR,1) > ONE) GO TO 9103
          OLDA=AMNT(NC)
          AMNT(NC)=ZERO
          OLDAET(1:NPETAS)=DAETA(NC,1:NPETAS)
          DAETA(NC,1:NPETAS)=ZERO
          IF (SECOND) THEN
            DO K=1,NPETAS
              DO J=K,NPETAS
                OLD2AE(J,K)=D2AETA(NC,J,K)
                D2AETA(NC,J,K)=ZERO
              END DO
            END DO
! Bauer.  SADVAN2->SADVAN under normal circumstances.  EM algorithms may redirect for efficiency purposes
            CALL SADVAN2(MICALL)
            IF (IERPRD > 0) GO TO 998
            DO K=1,NPETAS
              DO J=K,NPETAS
                D2AETA(NC,J,K)=D2AETA(NC,J,K)*GG(IFR,1)+DAETA(NC,K)*GG(IFR,J+1)+       &
                  DAETA(NC,J)*GG(IFR,K+1)+AMNT(NC)*G2(IFR,J,K)+OLD2AE(J,K)
              END DO
            END DO
          ELSE
! Bauer.  SADVAN2->SADVAN under normal circumstances.  EM algorithms may redirect for efficiency purposes
            CALL SADVAN2(MICALL)
            IF (IERPRD > 0) GO TO 998
          END IF
          DO K=1,NPETAS
            DAETA(NC,K)=DAETA(NC,K)*GG(IFR,1)+AMNT(NC)*GG(IFR,K+1)+OLDAET(K)
          END DO
          AMNT(NC)=AMNT(NC)*GG(IFR,1)+OLDA
        END IF
      END IF
!
      IF (DOSE .AND. .NOT. LAGDOS) THEN
        DTSTART=.TRUE.
        RATE=EVTREC(NEVENT,JRATE) ! Dose event, not steady state
        AMOUNT=EVTREC(NEVENT,JAMT)
        IF (GENMOD) THEN
          IF (SV(IC) == 0) THEN
            NBRON=NBRON+1
            MFLAG6=1
          END IF
          IF (RATE == 0) THEN
            MFLAG3=1
          ELSE
            MFLAG4=1
          END IF
        END IF
        SV(IC)=1
        IF (RATE == ZERO) THEN
          K=IBF(IC) ! Add instantaneous dose to state vector
          IF (GG(K,1) < ZERO) GO TO 9002
          AMNT(IC)=AMNT(IC)+AMOUNT*GG(K,1)
          IF (.NOT. NOETAS) THEN
            DO J=1,NPETAS
              DAETA(IC,J)=DAETA(IC,J)+AMOUNT*GG(K,J+1)
            END DO
            IF (SECOND) THEN
              DO KK=1,NPETAS
                DO J=KK,NPETAS
                  D2AETA(IC,J,KK)=D2AETA(IC,J,KK)+AMOUNT*G2(K,J,KK)
                END DO
              END DO
            END IF
          END IF
        END IF
      END IF
!
 2700 ICF=EVTREC(NEVENT,JCOMPT) ! Compute F for the appropriate compartment
      IF (.NOT. OBSERV) ICF=EVTREC(NEVENT,JCOMPF)
      IF (ICF == 0) ICF=IDO
      IF (ICF < 0) ICF=-ICF
      IF (ICF == 1000) ICF=NC               ! Always allow 1000 as the default output cmt 3/2013
      IF (ICF == 100 .AND. NC < 100) ICF=NC ! Allow 100 as the default output cmt if small model 3/2013
      ISCALE=IS(ICF)            ! Get scale
!
      IF (GG(ISCALE,1) <= ZERO) THEN
        ETEXT(2)='PK PARAMETER FOR OBSERVATION COMPARTMENT''S SCALE IS NON-POSITIVE'
        IERPRD=1; GO TO 998
      END IF
!
      IF (EVNUMBER <= 1 .OR. OBSERV) THEN !7.2
        F=AMNT(ICF)/GG(ISCALE,1)
!
        IF (IPS /= 2 .AND. .NOT. NOETAS) THEN  ! Check if G is to be computed from A
! Normal case
          DO KK=1,NPETAS
            G(IDXETA(KK),1)=(DAETA(ICF,KK)-F*GG(ISCALE,KK+1))/GG(ISCALE,1)
          END DO
          IF (SECOND) THEN                    ! Compute second deriv of F wrt ETA(J),ETA(KK)
            DO KK=1,NPETAS
              DO J=KK,NPETAS
                G(IDXETA(J),IDXETA(KK)+1)=(D2AETA(ICF,J,KK)-G(IDXETA(J),1)*              &
                  GG(ISCALE,KK+1)-F*G2(ISCALE,J,KK)-            &
                  G(IDXETA(KK),1)*GG(ISCALE,J+1))/GG(ISCALE,1)
              END DO
            END DO
          END IF
        END IF
! Decide whether to call error subroutine
! CALLER: 1=ALL, 2=OBS, 3=Once per indiv, 4=Once per problem
      END IF
!
      SELECT CASE (CALLER)
      CASE (1); GO TO 2790
      CASE (2); IF (OBSERV) GO TO 2790      ! Observation only
      CASE (3); IF (NEWIF /= 2) GO TO 2790  ! Once per Indiv
      CASE (4)                              ! GO TO 2780
      CASE DEFAULT
        CALL ERRORMSGS(307) ! ' ERROR IN PRED ROUTINE. VARIABLE "CALLER" IS NOT IN THE RANGE (1-4)'
        GO TO 999
      END SELECT
!
 2780 IF (.NOT. CALLE .AND. ICALL /= 4) GO TO 2800 ! Skip the call unless simulation step
!
 2790 CONTINUE !7.2
      IF (EVNUMBER <= 1 .OR. OBSERV) THEN !7.2
        IF (IPS == 2) G(1:NPEPS,1)=ZERO
        IF (IPS == 1 .AND. IFRSTDER == 0) G(1:XNPETA,1)=ZERO
      END IF
!
      IRET=2 ! Restore ETA derivatives to original positions in case A USED in ERROR
      IF (NAETA /= 0) GO TO 8000
!
 8001 CONTINUE
      CALL ERROR(ICALL,IDEF,THETA,IREV,EVTREC,NEVENT,INDXS(IXUSER),F,G,HH)
      NEVENTPREV2=NEVENT+10
      EVTREC(NEVENTPREV2,1:NDI)=EVTREC(NEVENT,1:NDI)
 8002 IF (IERPRD > 0) GO TO 998
!
 2800 CONTINUE !7.2
      IF (EVNUMBER <= 1 .OR. OBSERV) THEN !7.2
        IF (NPEPS /= 0) THEN
          IF (YFORM == 1) YMULT=F     ! PREDI sets YMULT=1.0
          IF (IPS == 2) THEN
            G(1:NPEPS,1)=HH(1:NPEPS,1)*YMULT
          ELSE IF (YFORM == 1) THEN   ! Use XNPETA rather than NPETAS in case IFRSTDER=0 6/95
            FORALL (J=1:XNPETA, I=1:NPEPS) H(I,J+1)=G(J,1)*HH(I,1)+YMULT*HH(I,J+1)
            H(1:NPEPS,1)=HH(1:NPEPS,1)*YMULT
          ELSE
            H(1:NPEPS,1:XNPETA+1)=HH(1:NPEPS,1:XNPETA+1)
          END IF
        END IF
      END IF
!
      IF (.NOT. OBSERV) THEN ! Branch according to event type
        IF (OTHER) THEN     ! Other event
          IF (EVTREC(NEVENT,JCOMPT) /= 0.0) THEN
            IF (EVTREC(NEVENT,JCOMPT) < 0.0) GO TO 4010
            IF (GENMOD .AND. (IC /= NC .AND. SV(IC) == 0)) THEN ! Turn compartment ON
              NBRON=NBRON+1
              MFLAG6=1
            END IF
            SV(IC)=1
          END IF
          GO TO 9000
        END IF
        IF (SSDOSE .OR. RATE == ZERO .OR. LAGDOS) GO TO 9000
        GO TO 5000
      END IF
!
      IF (EVTREC(NEVENT,JCOMPT) >= 0.0) GO TO 9000 ! Observation event
! Turn compartment off and re-initialize
 4010 IF (GENMOD .AND. (IC /= NC .AND. SV(IC) == 1)) THEN
        NBRON=NBRON-1
        MFLAG7=1
      END IF
!
      SV(IC)=0
      AMNT(IC)=ZERO
      DAETA(IC,1:NPETAS)=ZERO
!
      IF (SECOND) THEN
        DO KK=1,NPETAS
          DO J=KK,NPETAS
            D2AETA(IC,J,KK)=ZERO
          END DO
        END DO
      END IF
!
      IF (MCNTR > 0) THEN ! *** Turn off any delayed dose records for this compartment
        MSAVE=MCNTR
        J=0
        DO I=1,MMAX
          IF (MNEXT(I) == NOTDEFINED) CYCLE
          IF (MCMT(I) == IC) THEN
            MNEXT(I)=NOTDEFINED
            MCNTR=MCNTR-1
          END IF
          J=J+1
          IF (J >= MSAVE) THEN
            EXIT
          ENDIF
        END DO
      END IF
!
      IF (IINST(IC) == 0) GO TO 9000 ! Turn any infusions off
 4025 J=IHEAD
 4030 IF (J == 0) GO TO 9000
!
      IF (BETA(J) /= IC) THEN
        J=INEXT(J)
        GO TO 4030
      END IF
!
      IPOOL(IP)=J
      IP=IP-1
!
      IF (J /= IHEAD) THEN
        INEXT(IBACK(J))=INEXT(J)
        IF (INEXT(J) /= 0) IBACK(INEXT(J))=IBACK(J)
        J=INEXT(J)
        GO TO 4030
      END IF
!
      IHEAD=INEXT(J)
      GO TO 4025
!
 5000 IF (IP >= MAXIC) GO TO 9004 ! Zero-order absorbed dose (infusion)
      IP=IP+1                     ! Use next available slot in inf. arrays
      IF=IPOOL(IP)
      BETA(IF)=IC
      IF (IHEAD /= 0) IBACK(IHEAD)=IF
      INEXT(IF)=IHEAD
      IHEAD=IF
      K=IBF(IC)
      IA(IF)=RATE
!
      IF (NEWWAY .OR. RATE < ZERO) THEN
        IF (GG(K,1) < ZERO) GO TO 9002
        IAA(IF)=AMOUNT*GG(K,1)
      ELSE
        IAA(IF)=AMOUNT
      END IF
!
      IF (RATE == XD) THEN    ! Duration is modelled
        I=ID(IC)
        IF (GG(I,1) <= ZERO) GO TO 9005
        IDA(IF)=GG(I,1)
        IRA(IF)=IAA(IF)/IDA(IF)
        IF (.NOT. NOETAS) THEN
          DO J=1,NPETAS
            IDEA(IF,J)=GG(I,J+1)
            IREA(IF,J)=(AMOUNT*GG(K,J+1)-IRA(IF)*IDEA(IF,J))/IDA(IF)
          END DO
          IF (SECOND) THEN
            DO KK=1,NPETAS
              DO J=KK,NPETAS
                I2DEA(IF,J,KK)=G2(I,J,KK)
                I2REA(IF,J,KK)=(AMOUNT*G2(K,J,KK)-IREA(IF,J)*IDEA(IF,KK)-IRA(IF)*      &
                  I2DEA(IF,J,KK)-IREA(IF,KK)*IDEA(IF,J))/IDA(IF)
              END DO
            END DO
          END IF
        END IF
      ELSE IF (RATE == XR) THEN ! Rate is modelled
        IF (.NOT. NOETAS) THEN
          DO J=1,NPETAS
            IAEA(IF,J)=AMOUNT*GG(K,J+1)
          END DO
          IF (SECOND) THEN
            DO KK=1,NPETAS
              DO J=KK,NPETAS
                I2AEA(IF,J,KK)=AMOUNT*G2(K,J,KK)
              END DO
            END DO
          END IF
        END IF
      ELSE                      ! Constant rate
        IRA(IF)=RATE
        IDA(IF)=IAA(IF)/RATE
        IF (.NOT. NOETAS) THEN
          IF (NEWWAY) THEN
            DO J=1,NPETAS
              IAEA(IF,J)=AMOUNT*GG(K,J+1)
              IREA(IF,J)=ZERO
              IDEA(IF,J)=IAEA(IF,J)/RATE
            END DO
          ELSE
            IAEA(IF,1:NPETAS)=ZERO
            IREA(IF,1:NPETAS)=ZERO
            IDEA(IF,1:NPETAS)=ZERO
          END IF
          IF (SECOND) THEN
            IF (NEWWAY) THEN
              DO KK=1,NPETAS
                DO J=KK,NPETAS
                  I2AEA(IF,J,KK)=AMOUNT*G2(K,J,KK)
                  I2REA(IF,J,KK)=ZERO
                  I2DEA(IF,J,KK)=I2AEA(IF,J,KK)/RATE
                END DO
              END DO
            ELSE
              DO KK=1,NPETAS
                DO J=KK,NPETAS
                  I2AEA(IF,J,KK)=ZERO
                  I2REA(IF,J,KK)=ZERO
                  I2DEA(IF,J,KK)=ZERO
                END DO
              END DO
            END IF
          END IF
        END IF
      END IF ! End of EVENT record processing

!**** Do we need to call AES, DES?
 9000 IF (DIDCAA .AND. (COMACT /= 0 .OR. ICALL == 4)) THEN
! Reach here for ADVAN6,8,9 or any ADVAN with SS=6, if ADVAN/SS called
        IF (DIDDES .OR. DIDAES) THEN
          DOFINL=.TRUE.
          ISFINL=1
          TSTART=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF
! Bauer.  SADVAN2->SADVAN under normal circumstances.  EM algorithms may redirect for efficiency purposes
          IF (GENMOD) CALL SADVAN2(MICALL)
          IF (IERPRD > 0) THEN
            ISFINL=0
            DOFINL=.FALSE.
            DIDCAA=.FALSE.
            GO TO 998
          END IF
          IF (DIDDES .OR. DIDAES) THEN
!            IF(ADVID==16 .OR. ADVID==17) CALL PRED_TIMEVALUES_INFO()
            CALL SSS
            IF (IQUIT == 1) THEN
              ISFINL=0
              DOFINL=.FALSE.
              DIDCAA=.FALSE.
              GO TO 999
            END IF
          END IF
          IF (IERPRD > 0) THEN
            ISFINL=0
            DOFINL=.FALSE.
            DIDCAA=.FALSE.
            GO TO 998
          END IF
          DOFINL=.FALSE.
          ISFINL=0
        END IF
        DIDCAA=.FALSE.
      END IF
!**** Create new delayed dose *****
      IF (DABS(EVTREC(NEVENT,JMORE)) /= 0 .OR. LAGDOS) THEN
        IF (MCNTR == 0) MNEXT(1:MMAX)=NOTDEFINED ! Initialize the MNEXT array only when first needed
        MCNTR=MCNTR+1
        IF (MCNTR > MMAX) THEN
          ETEXT(2)='THE NUMBER OF PENDING ADDITIONAL AND/OR LAGGED DOSES IS TOO LARGE'
          IERPRD=1; GO TO 998
        END IF
        DO I=1,MMAX
          IF (MNEXT(I) == NOTDEFINED) EXIT
        END DO
        SAVDOS(1:PD1,I)=EVTREC(NEVENT,1:PD1)
        MTIME(I)=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF
        IF(ADDL_TIMEDIFF/=0.0D+00) THEN
          IF(SAVDOS(JTIME,I)==FIRST_JTIME.AND.SAVDOS(JMORE,I)==FIRST_JMORE.AND.SAVDOS(JDELTA,I)==FIRST_JDELTA) THEN
            SAVDOS(JMORE,I)=FIRST_JMORE2
          ENDIF
          IF(SAVDOS(JTIME,I)>=FIRST_JTIME2) THEN
            SAVDOS(JTIME,I)=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF
          ENDIF
        ENDIF
!        DTSTART=.TRUE.
        MCMT(I)=IC
        MNBR(I)=1
        MNEXT(I)=MTIME(I)+SAVDOS(JDELTA,I)
        MLAG(I)=0
        IF (LAGDOS) THEN
          MLAG(I)=1
          MNBR(I)=0
          IF (GG(ILAG(IC),1) < 0) THEN
            ETEXT(2)='PK PARAMETER FOR ABSORPTION LAG IS NEGATIVE'
            IERPRD=1; GO TO 998
          END IF
          MTIME(I)=MTIME(I)+GG(ILAG(IC),1)
!          DTSTART=.TRUE.
          MNEXT(I)=MTIME(I)
          IF (.NOT. NOETAS) THEN
            DO K=1,NPETAS
              DMTIME(I,K)=GG(ILAG(IC),K+1)
            END DO
            IF (SECOND) THEN
              DO K=1,NPETAS
                DO J=K,NPETAS
                  D2MTIM(I,J,K)=G2(ILAG(IC),J,K)
                END DO
              END DO
            END IF
          END IF
        ELSE IF (.NOT. NOETAS) THEN
          DMTIME(I,1:NPETAS)=ZERO
          IF (SECOND) THEN
            DO K=1,NPETAS
              DO J=K,NPETAS
                D2MTIM(I,J,K)=ZERO
              END DO
            END DO
          END IF
        END IF
      END IF    !***** End create new delayed dose ****
!
      T1=T2
      NEWIF=2
      DTIME=.FALSE.
!
      IF (ODTIME) THEN
        DO K=1,NPETAS
          DDELTA(K)=ZERO
          DTSTAR(K)=ZERO
          IF (SECOND) THEN
            DO J=K,NPETAS
              D2DELT(J,K)=ZERO
              D2TSTA(J,K)=ZERO
            END DO
          END IF
        END DO
      END IF
!
      ODTIME=.FALSE.
      IF (ICALL == 4) THEN
        DO J=1,NDI
!          IF(J==JTIME.AND.ADDL_TIMEDIFF/=0.0D+00) CYCLE
          DATREC(J)=EVTREC(NEVENT,J)
        ENDDO
      ENDIF
      IF (EVENT_REPEAT(2,NEVENT,ICALL) /= 0) THEN
        NEVENT=0
        GO TO 1500 !7.2
      END IF
      NEVENT=0
      GO TO 999
!
 6005 MINTIM=NOTDEFINED
      DDSTOP=.FALSE.
      MESTOP=.FALSE.
!
      IF (MCNTR > 0) THEN
        J=0
        DO I=1,MMAX
          IF (MNEXT(I) == NOTDEFINED) CYCLE
          IF (MINTIM == NOTDEFINED .OR. MINTIM > MNEXT(I)) THEN
            MINTIM=MNEXT(I)
            MSAVE=I
          END IF
          J=J+1
          IF (J >= MCNTR) EXIT
        END DO
      END IF
!
      IF (MTCNTR > 0) THEN  ! Get next model event time
        IF (MTPTR > MTCNTR) THEN
          METIME=T2+100
        ELSE IF (GG(IMTGG(MTPTR),1) >= TSTART) THEN
          METIME=GG(IMTGG(MTPTR),1)
        ELSE
          METIME=T2+100D+00
        END IF
      END IF
!
      IF (MCNTR > 0 .AND. MTCNTR > 0) THEN ! Case 1 - Both
        IF (MINTIM > T2 .AND. METIME > T2) GO TO 6825
! With LE, makes LAGTIME stops preceded MTIME stops when both are =
! With LT, MTIME stop precedes LAGTIME stop when ALAG=MTIME
!       IF (MINTIM <= METIME) THEN
        IF (MINTIM < METIME) THEN
          DDSTOP=.TRUE.
        ELSE
          MESTOP=.TRUE.
          MINTIM=METIME
        END IF
      ELSE IF (MCNTR > 0 .AND. MTCNTR == 0) THEN   ! Case 2 - Only delayed doses
        IF (MINTIM > T2) GO TO 6825
        DDSTOP=.TRUE.
      ELSE IF (MCNTR == 0 .AND. MTCNTR > 0) THEN   ! Case 3 - Only model event times
        IF (METIME > T2) GO TO 6825
        MESTOP=.TRUE.
        MINTIM=METIME
      END IF
!
      IF (MESTOP) THEN ! Set model event time spikes
        IF (GG(IMTGG(MTPTR),1) == METIME) THEN
          MTNEXT(IMT(MTPTR))=1
          MTNOW=IMT(MTPTR)
        END IF
      END IF
! Advance to time of next additional dose
! BUG: Next line was added 9/95: IF CALLFL=1, Don't even think about it.
! May need to call pk with delayed dose
      IF (CALLPK /= 3 .AND. (CALLID /= 0 .OR. .NOT. DIDCAL)) THEN
        IF (CALLID == 1 .AND. DDSTOP) THEN
          DOSREC(1:PD)=SAVDOS(1:PD,MSAVE)   ! PD: Cols. in DATREC (not currently a NONMEM parameter)
          DOSTIM=MNEXT(MSAVE)
          IF (.NOT. NOETAS) THEN
            DDOST(1:NPETAS)=DMTIME(MSAVE,1:NPETAS)
            IF (SECOND) D2DOST(1:NPETAS,1:NPETAS)=D2MTIM(MSAVE,1:NPETAS,1:NPETAS)
          END IF
        END IF
        DELAY=.TRUE.
        GO TO 2109 ! Call PK with delayed dose
      END IF ! Return from call PK with delayed dose
! This is the point where DOSTIM was set to zero prior to 12/4/96. Code was moved so that
! DES, AES could see DOSREC,DOSTIM. A branch to 6019 occurs above, but cannot have both
! CALLFL=1 and CALLID=1, so its ok to move the CALLID == 1 code down below.
 6019 IF (GG(ITSC,1) == ZERO) GO TO 9007
      DELTA=MINTIM-TSTART
      DSUM=ZERO
      DTIME=.FALSE.
!
      IF ((DDSTOP .OR. MESTOP) .AND. .NOT. NOETAS) THEN
        DO K=1,NPETAS
          DDELTA(K)=-DTSTAR(K)
          DSUM=DSUM+ABS(DTSTAR(K))
        END DO
        IF (SECOND) THEN
          DO K=1,NPETAS
            DO J=K,NPETAS
              D2DELT(J,K)=-D2TSTA(J,K)
              DSUM=DSUM+ABS(D2TSTA(J,K))
            END DO
          END DO
        END IF
!
        IF (DDSTOP) THEN
          IF (MLAG(MSAVE) == 1) THEN
            DO K=1,NPETAS
              DDELTA(K)=DDELTA(K)+DMTIME(MSAVE,K)
              DSUM=DSUM+ABS(DMTIME(MSAVE,K))
            END DO
            IF (SECOND) THEN
              DO K=1,NPETAS
                DO J=K,NPETAS
                  D2DELT(J,K)=D2DELT(J,K)+D2MTIM(MSAVE,J,K)
                  DSUM=DSUM+ABS(D2MTIM(MSAVE,J,K))
                END DO
              END DO
            END IF
          END IF
        END IF
!
        IF (MESTOP) THEN
          DO K=1,NPETAS
            DDELTA(K)=DDELTA(K)+GG(IMTGG(MTPTR),K+1)
! AJB 9/2013 bug fix.
!           DSUM=DSUM+GG(IMTGG(MTPTR),K+1)
            DSUM=DSUM+ABS(GG(IMTGG(MTPTR),K+1))
          END DO
          IF (SECOND) THEN
            DO K=1,NPETAS
              DO J=K,NPETAS
                D2DELT(J,K)=D2DELT(J,K)+G2(IMTGG(MTPTR),J,K)
                DSUM=DSUM+ABS(G2(IMTGG(MTPTR),J,K))
              END DO
            END DO
          END IF
        END IF
      END IF
! If DT or any of its derivatives is non-zero ....
! END IF for the following moved 3/99. Did not set DOSTIM=0 when two ALAG's had same value
! and had no derivatives
      IF (DELTA+DSUM > 0) THEN
        DTIME=DSUM /= ZERO
        IF (DTIME) ODTIME=.TRUE.
        IF (IFR /= IRGG .AND. SV(NC) /= 0) THEN
          IF (GG(IFR,1) < ZERO) GO TO 9102
          IF (GG(IFR,1) > ONE) GO TO 9103
          OLDA=AMNT(NC) ! Output compartment fraction in effect
          AMNT(NC)=ZERO
          OLDAET(1:NPETAS)=DAETA(NC,1:NPETAS)
          DAETA(NC,1:NPETAS)=ZERO
          IF (SECOND) THEN
            DO KK=1,NPETAS
              DO J=KK,NPETAS
                OLD2AE(J,KK)=D2AETA(NC,J,KK)
                D2AETA(NC,J,KK)=ZERO
              END DO
            END DO
! Bauer.SADVAN2->SADVAN under normal circumstances.  EM algorithms may redirect for efficiency purposes
            CALL SADVAN2(MICALL)
            IF (IERPRD > 0) GO TO 998
            DO KK=1,NPETAS
              DO J=KK,NPETAS
                D2AETA(NC,J,KK)=D2AETA(NC,J,KK)*GG(IFR,1)+DAETA(NC,KK)*GG(IFR,J+1)+    &
                  DAETA(NC,J)*GG(IFR,KK+1)+AMNT(NC)*G2(IFR,J,KK)+OLD2AE(J,KK)
              END DO
            END DO
          ELSE
! Bauer.SADVAN2->SADVAN under normal circumstances.  EM algorithms may redirect for efficiency purposes
            CALL SADVAN2(MICALL)
            IF (IERPRD > 0) GO TO 998
          END IF
          DO K=1,NPETAS
            DAETA(NC,K)=DAETA(NC,K)*GG(IFR,1)+AMNT(NC)*GG(IFR,K+1)+OLDAET(K)
          END DO
          AMNT(NC)=AMNT(NC)*GG(IFR,1)+OLDA
        ELSE
! Bauer.SADVAN2->SADVAN under normal circumstances.  EM algorithms may redirect for efficiency purposes
          IF(MSAVE>0.AND.PREDADDL_ON/=0) THEN ! Negative ADDL, empirical SS method, nm75a7 3/2019 rjb
            IF(SAVDOS(JDELTA,MSAVE)>0.0D+00.AND.SAVDOS(JMORE,MSAVE)<0.0D+00.AND.ADDL_TIMEDIFF==0.0D+00) THEN
              IF(MOD((TSTART-SAVDOS(JTIME,MSAVE)),SAVDOS(JDELTA,MSAVE))==0.0D+00) THEN
                NWW=0
                NWW2=0
                DO I=1,NC
                  IF(AMNT(I)==0.0D+00.AND.AMNTO(I)==0.0D+00) CYCLE
                  NWW2=NWW2+1
                  DSUM0=DABS(AMNT(I)-AMNTO(I))
                  DSUM2=(DABS(AMNT(I))+DABS(AMNTO(I)))/2.0D+00
                  IF(DSUM0>SSTOL*DSUM2+SSATOL) NWW=NWW+1
                ENDDO
                AMNTO(1:NC)=AMNT(1:NC)
                IF(NWW==0.AND.NWW2>0) THEN
                  DSUM0=DABS(SAVDOS(JMORE,MSAVE))
                  DJMORE=INT((TSTART-SAVDOS(JTIME,MSAVE))/SAVDOS(JDELTA,MSAVE)+2.0)
                  IF(DJMORE<DSUM0.AND.DJMORE>0) THEN
                    FIRST_JMORE=SAVDOS(JMORE,MSAVE)
                    FIRST_JTIME=SAVDOS(JTIME,MSAVE)
                    FIRST_JDELTA=SAVDOS(JDELTA,MSAVE)
                    FIRST_JMORE2=DJMORE
                    SAVDOS(JMORE,MSAVE)=DJMORE
                    ADDL_TIMEDIFF=(DJMORE-DSUM0)*SAVDOS(JDELTA,MSAVE)
                    FIRST_JTIME2=SAVDOS(JTIME,MSAVE)+DJMORE*SAVDOS(JDELTA,MSAVE)
                    T1=T1+ADDL_TIMEDIFF
                    T2=T2+ADDL_TIMEDIFF
                    SAVDOS(JTIME,MSAVE)=SAVDOS(JTIME,MSAVE)+ADDL_TIMEDIFF
                    ADDL_TIME=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF
!                    EVTREC(NEVENT,JTIME)=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF
!                    DATREC(JTIME)=DATREC(JTIME)+ADDL_TIMEDIFF
                    ADDL_ACTUAL=DJMORE
                    DO I=1,MSAVE-1
                      IF(SAVDOS(JTIME,I)==FIRST_JTIME.AND.SAVDOS(JMORE,I)==FIRST_JMORE.AND.SAVDOS(JDELTA,I)==FIRST_JDELTA) THEN
                        SAVDOS(JMORE,I)=FIRST_JMORE2
                      ENDIF
                      IF(SAVDOS(JTIME,I)>=FIRST_JTIME2) SAVDOS(JTIME,I)=EVTREC(NEVENT,JTIME)+ADDL_TIMEDIFF
                    ENDDO
! =1000 TURNS OFF THIS ACTION, AS IT NEVER HAPPENS.  =1 TURNS IT ON WHENEVER DATREC IS READ/WRITE MODE
                    IF(DATNN_PREVM(1)==1000) THEN
                      DPREV=DATREC(JMORE)
                      IPREV=DATNN_PREV(1)
                      CALL DAT1 (IPREV-1,1,0)
                      DATREC(JMORE)=DJMORE
                      CALL DAT1 (IPREV,1,0)
                      DATREC(JMORE)=DPREV
                    ENDIF
                  ENDIF
!                  IF(NEVENTPREV<=0) NEVENTPREV=NEVENT
!                  IF(NEVENTPREV2<=0) NEVENTPREV2=NEVENT
                  IF(NEVENTPREV>0) CALL PK(ICALL,IDEF,THETA,IREV,EVTREC,NEVENTPREV,INDXS(IXUSER),IRGG,G3,XNPETA)
                  IF(NEVENTPREV2>0) CALL ERROR(ICALL,IDEF,THETA,IREV,EVTREC,NEVENTPREV2,INDXS(IXUSER),F,G,HH)
                ENDIF
              ENDIF
            ENDIF
          ENDIF
          CALL SADVAN2(MICALL) ! No output compartment fraction or output compartment is off
          IF (IERPRD > 0) GO TO 998
        END IF
      END IF ! This is new location of END IF for "IF (DELTA+DSUM > 0) ..."  AJB 3/99
!
! Add this set of calls so that STUART can test DOFINL in the DES routine - allows write
! in DES only after finishing the advance to non-event or event time. 5/99
      IF (DIDCAA .AND. (COMACT /= 0 .OR. ICALL == 4)) THEN
        IF (DIDDES .OR. DIDAES) THEN ! Reach here for ADVAN6,8,9 or any ADVAN with SS=6, if ADVAN/SS called
          DOFINL=.TRUE.
          ISFINL=1
          TSTART=MINTIM
          DTSTART=.TRUE.
! Bauer.SADVAN2->SADVAN under normal circumstances.  EM algorithms may redirect for efficiency purposes


          IF (GENMOD) CALL SADVAN2(MICALL)
          IF (IERPRD > 0) THEN
            ISFINL=0
            DOFINL=.FALSE.
            DIDCAA=.FALSE.
            GO TO 998
          END IF
          IF (DIDDES .OR. DIDAES) THEN
            RADAR5NM_RESUME=0
            IF(DDERESUMENM/=0) DDERESUMENM=10
            IF(ADVID==16 .OR. ADVID==17.OR. ADVID==18) CALL PRED_TIMEVALUES_INFO()
            CALL SSS
            IF (IQUIT == 1) THEN
              ISFINL=0
              DOFINL=.FALSE.
              DIDCAA=.FALSE.
              GO TO 999
            END IF
          END IF
          IF (IERPRD > 0) THEN
            ISFINL=0
            DOFINL=.FALSE.
            DIDCAA=.FALSE.
            GO TO 998
          END IF
          DOFINL=.FALSE.
          ISFINL=0
        END IF
        DIDCAA=.FALSE.
      END IF
!
      IF (CALLID == 1 .AND. DDSTOP) THEN ! This is the new point to set DOSREC,DOSTIM to zero. 12/4/96
        DOSREC=ZERO  ! DOSREC(1:PD)=ZERO
        DOSTIM=ZERO
        IF (.NOT. NOETAS) THEN
          DDOST(1:NPETAS)=ZERO
          IF (SECOND) D2DOST(1:NPETAS,1:NPETAS)=ZERO
        END IF
      END IF ! End of moved code. 12/4/96
!
      TSTART=MINTIM
      DTSTART=.TRUE.
!
      IF (DDSTOP .OR. MESTOP) THEN
        IF (DDSTOP) THEN
          LFLAG=MLAG(MSAVE) == 1 ! Fix bug in T with LAGTIME
          IF (.NOT. NOETAS) THEN
            DTSTAR(1:NPETAS)=DMTIME(MSAVE,1:NPETAS)
            IF (SECOND) THEN
              DO K=1,NPETAS
                DO J=K,NPETAS
                  D2TSTA(J,K)=D2MTIM(MSAVE,J,K)
                END DO
              END DO
            END IF
          END IF
        END IF
        IF (MESTOP) THEN
          LFLAG=.TRUE.
          IF (.NOT. NOETAS) THEN
            IF (.NOT. DDSTOP) THEN
              DO K=1,NPETAS
                DTSTAR(K)=GG(IMTGG(MTPTR),K+1)
              END DO
              IF (SECOND) THEN
                DO K=1,NPETAS
                  DO J=K,NPETAS
                    D2TSTA(J,K)=G2(IMTGG(MTPTR),J,K)
                  END DO
                END DO
              END IF
            ELSE
              DO K=1,NPETAS
                DTSTAR(K)=DTSTAR(K)+GG(IMTGG(MTPTR),K+1)
              END DO
              IF (SECOND) THEN
                DO K=1,NPETAS
                  DO J=K,NPETAS
                    D2TSTA(J,K)=D2TSTA(J,K)+G2(IMTGG(MTPTR),J,K)
                  END DO
                END DO
              END IF
            END IF
          END IF
        END IF
        IF (.NOT. DDSTOP) GO TO 6800
      END IF
! This was previous location of END IF for "IF (DELTA+DSUM > 0) ..." AJB 3/99
!     END IF
!
      MIC=MCMT(MSAVE)           ! Now apply this dose
      RATE=SAVDOS(JRATE,MSAVE)  ! BUG: Rate and amount were set below the test 3/93
      AMOUNT=SAVDOS(JAMT,MSAVE)
!
      IF (GENMOD) THEN
        IF (SV(MIC) == 0) THEN
          NBRON=NBRON+1
          MFLAG6=1
        END IF
        IF (RATE == 0) THEN
          MFLAG3=1
        ELSE
          MFLAG4=1
        END IF
      END IF
!
      SV(MIC)=1
!
      IF (RATE == ZERO) THEN  ! Add instantaneous dose to state vector
        MFLAG3=1
        K=IBF(MIC)
        IF (GG(K,1) < ZERO) GO TO 9002
        AMNT(MIC)=AMNT(MIC)+AMOUNT*GG(K,1)
        IF (.NOT. NOETAS) THEN
          DO J=1,NPETAS
            DAETA(MIC,J)=DAETA(MIC,J)+AMOUNT*GG(K,J+1)
          END DO
          IF (SECOND) THEN
            DO KK=1,NPETAS
              DO J=KK,NPETAS
                D2AETA(MIC,J,KK)=D2AETA(MIC,J,KK)+AMOUNT*G2(K,J,KK)
              END DO
            END DO
          END IF
        END IF
      ELSE                  ! Zero-order absorbed dose (infusion)
        MFLAG4=1
        IF (IP >= MAXIC) GO TO 9004
        IP=IP+1             ! Use next available slot in inf. arrays
        IF=IPOOL(IP)
        BETA(IF)=MIC
        IF (IHEAD /= 0) IBACK(IHEAD)=IF
        INEXT(IF)=IHEAD
        IHEAD=IF
        IA(IF)=RATE
        K=IBF(MIC)
        IF (NEWWAY .OR. RATE < ZERO) THEN
          IF (GG(K,1) < ZERO) GO TO 9002
          IAA(IF)=AMOUNT*GG(K,1)
        ELSE
          IAA(IF)=AMOUNT
        END IF
!
        IF (RATE == XD) THEN ! Duration is modelled
          I=ID(MIC)
          IF (GG(I,1) <= ZERO) GO TO 9005
          IDA(IF)=GG(I,1)
          IRA(IF)=IAA(IF)/IDA(IF)
          IF (.NOT. NOETAS) THEN
            DO J=1,NPETAS
              IDEA(IF,J)=GG(I,J+1)
              IREA(IF,J)=(AMOUNT*GG(K,J+1)-IRA(IF)*IDEA(IF,J))/IDA(IF)
            END DO
            IF (SECOND) THEN
              DO KK=1,NPETAS
                DO J=KK,NPETAS
                  I2DEA(IF,J,KK)=G2(I,J,KK)
                  I2REA(IF,J,KK)=(AMOUNT*G2(K,J,KK)-IREA(IF,J)*IDEA(IF,KK)-IRA(IF)*    &
                    I2DEA(IF,J,KK)-IREA(IF,KK)*IDEA(IF,J))/IDA(IF)
                END DO
              END DO
            END IF
          END IF
        ELSE IF (RATE == XR) THEN   ! Rate is modelled
          IF (.NOT. NOETAS) THEN
            DO J=1,NPETAS
              IAEA(IF,J)=AMOUNT*GG(K,J+1)
            END DO
            IF (SECOND) THEN
              DO KK=1,NPETAS
                DO J=KK,NPETAS
                  I2AEA(IF,J,KK)=AMOUNT*G2(K,J,KK)
                END DO
              END DO
            END IF
          END IF
        ELSE                        ! Constant rate
          IRA(IF)=RATE
          IDA(IF)=IAA(IF)/RATE
          IF (.NOT. NOETAS) THEN
            IF (NEWWAY) THEN
              DO J=1,NPETAS
                IAEA(IF,J)=AMOUNT*GG(K,J+1)
                IREA(IF,J)=ZERO
                IDEA(IF,J)=IAEA(IF,J)/RATE
              END DO
            ELSE
              IAEA(IF,1:NPETAS)=ZERO
              IREA(IF,1:NPETAS)=ZERO
              IDEA(IF,1:NPETAS)=ZERO
            END IF
            IF (SECOND .AND. NEWWAY) THEN
              DO KK=1,NPETAS
                DO J=KK,NPETAS
                  I2AEA(IF,J,KK)=AMOUNT*G2(K,J,KK)
                  I2REA(IF,J,KK)=ZERO
                  I2DEA(IF,J,KK)=I2AEA(IF,J,KK)/RATE
                END DO
              END DO
            ELSE
              DO KK=1,NPETAS
                DO J=KK,NPETAS
                  I2AEA(IF,J,KK)=ZERO
                  I2REA(IF,J,KK)=ZERO
                  I2DEA(IF,J,KK)=ZERO
                END DO
              END DO
            END IF
          END IF
        END IF
      END IF
!
 6800 IF (MCNTR > 0 .AND. DDSTOP) THEN ! Now update this dose
        IF (MNBR(MSAVE) < DABS(SAVDOS(JMORE,MSAVE))) THEN
          MNBR(MSAVE)=MNBR(MSAVE)+1
          MNEXT(MSAVE)=MTIME(MSAVE)+MNBR(MSAVE)*SAVDOS(JDELTA,MSAVE)
        ELSE
          MNEXT(MSAVE)=NOTDEFINED
          MCNTR=MCNTR-1
        END IF
      END IF
!
      EXTRST=.FALSE. ! Change spikes into basis
!
      IF (MESTOP) THEN
        MTNEXT(IMT(MTPTR))=0
        MTPAST(IMT(MTPTR))=1
        MTNOW=0
        MTPTR=MTPTR+1
! Sort the model event times for call PK at non-event time (this happens after the original stop)
        IF (NEWIF /= 2 .OR. MTDIFF /= 0) EXTRST=.TRUE.
      END IF
! Added 4/25 - check MTIME after call to PK with DOSTIM /= 0
      IF (DDSTOP .AND. MTDIFF /= 0) EXTRST=.TRUE.
      IF (EXTRST) GO TO 1000
 !
 6801 CONTINUE
      EXTRST=.FALSE. ! Return here from sort the model event times
!
      IF (MTNO /= 0) THEN
        IF (MCNTR /= 0 .OR. (MTCNTR > 0 .AND. METIME < T2)) GO TO 6005
      ELSE
        IF (MCNTR /= 0) GO TO 6005
      END IF
!
 6825 CONTINUE
      DELTA=T2-TSTART
!
      IF (ODTIME) THEN
        DTIME=.TRUE.
        DDELTA(1:NPETAS)=-DTSTAR(1:NPETAS)
        IF (SECOND) THEN
          DO K=1,NPETAS
            DO J=K,NPETAS
              D2DELT(J,K)=-D2TSTA(J,K)
            END DO
          END DO
        END IF
      END IF

      IF (CALLID == 0 .AND. DIDCAL) GO TO 2200 ! Exit after call PK
      GO TO 6900       ! Exit to call PK
!*** End code for additional doses ******
!
 8000 IF (NOETAS .OR. MSAME) THEN ! Start of code to expand DAETA to correct positions for error
        SELECT CASE (IRET)
        CASE (1); GO TO 8003
        CASE (2); GO TO 8001
        CASE DEFAULT
          CALL ERRORMSGS(301) ! ' ERROR IN PRED ROUTINE. VARIABLE "IRET" IS NOT IN THE RANGE (1-2)'
          GO TO 999
        END SELECT
      END IF
!
      IF (IRET == 1 .AND. (IPKA == 0 .OR. AZERO)) GO TO 8003
      IF (IRET == 2 .AND. IERRA == 0) GO TO 8001
! Should have the same test for PK: If does not use A on right, do noth
      DOLDS(1:NC,1:XNPETA)=DAETA(1:NC,1:XNPETA)
      DAETA(1:NC,1:XNPETA)=ZERO
      DAETA(1:NC,IDXETA(1:NPETAS))=DOLDS(1:NC,1:NPETAS)
!
      IF (SECOND) THEN
        DO KK=1,XNPETA
          DO NN=KK,XNPETA
            D2OLDS(1:NC,NN,KK)=D2AETA(1:NC,NN,KK)
            D2AETA(1:NC,NN,KK)=ZERO
          END DO
        END DO
        DO KK=1,NPETAS
          DO NN=KK,NPETAS
            D2AETA(1:NC,IDXETA(NN),IDXETA(KK))=D2OLDS(1:NC,NN,KK)
          END DO
        END DO
      END IF
!
      IF (IRET == 2) THEN
        CALL ERROR(ICALL,IDEF,THETA,IREV,EVTREC,NEVENT,INDXS(IXUSER),F,G,HH)
        NEVENTPREV2=NEVENT+10
        EVTREC(NEVENTPREV2,1:NDI)=EVTREC(NEVENT,1:NDI)
      ELSE
        CALL PK(ICALL,IDEF,THETA,IREV,EVTREC,NEVENT,INDXS(IXUSER),IRGG,G3,XNPETA)
        NEVENTPREV=NEVENT+5
        EVTREC(NEVENTPREV,1:NDI)=EVTREC(NEVENT,1:NDI)
        IF (IQUIT == 1) GO TO 999
        IF (IERPRD > 0) GO TO 998
      END IF
!
      DAETA(1:NC,1:XNPETA)=DOLDS(1:NC,1:XNPETA)
!
      IF (SECOND) THEN
        DO KK=1,XNPETA
          DO NN=KK,XNPETA
            D2AETA(1:NC,NN,KK)=D2OLDS(1:NC,NN,KK)
          END DO
        END DO
      END IF
!
      SELECT CASE (IRET)
      CASE (1); GO TO 8004
      CASE (2); GO TO 8002
      CASE DEFAULT
        CALL ERRORMSGS(301)  ! ' ERROR IN PRED ROUTINE. VARIABLE "IRET" IS NOT IN THE RANGE (1-2)'
        GO TO 999
      END SELECT
!
 8500 IF (A_0FLG /= 0.OR.A_UFLG/=0) THEN ! Start of code to copy amnt after call to PK for the A0 feature
        IF(A_0FLG/=0.AND.A_UFLG/=0) THEN
          CALL ERRORMSGS(509)
          GO TO 999
        ENDIF
        A_0FLG=0
        IF(A_UFLG/=0) THEN
          IF(TSTATE==TSTATEP.AND.AFLGUP/=0) THEN
            AFLGUP=A_UFLG
            A_UFLG=0
            GO TO 8501
          ENDIF
        ENDIF
        TSTATEP=TSTATE
        AFLGUP=A_UFLG
        A_UFLG=0
        AZERO=.FALSE.
        DO I=1,NC
          IF(A_0(I)/=AMNT(I)) THEN
            IF(SV(I)==0) THEN
              MFLAG6=1
              NBRON=NBRON+1 ! this is the critical line
            ENDIF
            MFLAG3=1
            SV(I)=1
          ENDIF
        ENDDO
        AMNT(1:NC)=A_0(1:NC)
        IF (.NOT. NOETAS) THEN
! No need to zero out positions that were not copied - this was done already
          DAETA(1:NC,1:NPETAS)=DA_0(1:NC,IDXETA(1:NPETAS))
          IF (SECOND) THEN
            DO KK=1,NPETAS
              DO NN=KK,NPETAS
                D2AETA(1:NC,NN,KK)=D2A_0(1:NC,IDXETA(NN),IDXETA(KK))
              END DO
            END DO
          END IF
        END IF
      END IF
!
      GO TO 8501
!
 9002 ETEXT(2)='PK PARAMETER FOR BIOAVAILABILITY FRACTION IS NEGATIVE' ! Code for error return from PRED
      IERPRD=1; GO TO 998
 9004 WRITE (CTEMP,'(I4)') MAXIC
      ETEXT(2)='NUMBER OF INFUSIONS ACTIVE AT THIS TIME EXCEEDS THE MAXIMUM ('//CTEMP//')'
      ETEXT(3)='PERHAPS THE DURATIONS ARE TOO LONG'
      IERPRD=1; GO TO 998
 9005 ETEXT(2)='PK PARAMETER FOR DURATION IS NON-POSITIVE'
      IERPRD=1; GO TO 998
 9007 ETEXT(2)='PK PARAMETER FOR TIME SCALE IS ZERO'
      IERPRD=1; GO TO 998
 9102 ETEXT(2)='PK PARAMETER FOR OUTPUT FRACTION IS NEGATIVE'
      IERPRD=1; GO TO 998
 9103 ETEXT(2)='PK PARAMETER FOR OUTPUT FRACTION IS GREATER THAN ONE'
      IERPRD=1
! Code for error return from SADVAN and SSS as well as from PRED
 998  CONTINUE
!
      IF (IP /= 0 .OR. IHEAD /= 0) THEN ! Reinitialize infusion counters - fixes BUG 1/94
        FORALL (I=1:MAXIC) IPOOL(I)=I
        IHEAD=0; IP=0
      END IF
!
      NETEXT=0
!
      IF (ETEXT(1) == ' ') THEN
        WK132=ETEXT(2)      ! Use of WK132 avoids warning message in CFT77
        ETEXT(1)=WK132
        ETEXT(2)=' '
      END IF
!
      IF (ETEXT(2) == ' ') THEN
        WK132=ETEXT(3)
        ETEXT(2)=WK132
        ETEXT(3)=' '
      END IF
!
      DO I=1,3
        IF (ETEXT(I) /= ' ') NETEXT=NETEXT+1
      END DO
!
      ISFINL=0
      GO TO 999
!
 7020 U=1+KEND+KEND*(KEND+1)/2-(KETA-1)*KETA/2
!
      IF (U*XNCM1 > SPW) THEN
        KEND=KEND-1; GO TO 7020
      END IF
!
      SLOOP=SLOOP+1
      SLEND(SLOOP)=KEND
      SLST(SLOOP)=KETA
!
      IF (KEND < NACTIV) THEN
        KETA=KEND+1
        KEND=NACTIV
        GO TO 7020
      END IF
!
      GO TO 7999
!
  999 RETURN
!
      END SUBROUTINE PRED
!
!-----------------------------HISTORY------------------------------------------------
! VERSION     : NONMEM VII
! AUTHOR      : ROBERT J. BAUER
! CREATED ON  : DEC/2008
! LANGUAGE    : FORTRAN 90/95
! LAST UPDATE : DEC/2008 - INTRODUCED HEADER INFORMATIONS AND RESTRUCTURED AS PER
!                          THE NONMEM STANDARDS
!               MAR/2009 - COMMON BLOCKS OF BAYES MODEL REPLACED WITH MODULES
!               FEB/2010 - CHANGED SIZES TO PRSIZES
!
!----------------------------------- SADVAN2.F90 ------------------------------------
!
! SUBROUTINE SADVAN2(MICALL)
!
! DESCRIPTION :
!
! ARGUMENTS   : MICALL
!               IN     - MICALL
!                        MICALL - ICALL, indicator variable that can have value from
!                                 0 to 6
!               OUT    - NONE
!               IN OUT - NONE
!
! CALLED BY   : PRED - This is PREDPP main program. Provides prediction, partial 
!                      derivatives of the statistical model with respect to ETA
!                      and EPSILON random variables and stores them in the G
!                      and H arguments of the PRED routine.
!
! CALLS       : SADVAN - Stands for Supervisor ADVAN.  This is an interface.
!                        PREDPP contains a library of routines, called ADVAN routines,
!                        which implement specific kinetic models. Exactly one ADVAN
!                        routine must be selected for each NONMEM / PREDPP run.
!                        Its function is to "ADVANCE" the kinetic system from one
!                        state time point to the next
!            : ERRORMSGS
!
! ALGORITHM   : - Branch over ISADVAN2 and ISADVAN2_REC > MAXRECID
!               - Call SADVAN
!               - Update global variables and return
!
! MODULES USED: PRSIZES,PR_BAYES_INT2,PR_BAYES_REAL2,SIZES,NMPRD_INT,PRCOM_INT,
!               PROCM_INT,NM_BAYES_INT,NMBAYES_INT,PRCOM_LOG,PR_BAYES_LOG,PROCM_REAL,
!               PRCOM_REAL,PR_INTERFACE,NM_INTERFACE
!
! CONTAINS    : NONE
!
! LOCALS      : I,J,K
!
!---------------------------- END OF HEADER -----------------------------------------
!
! The remaining lines are from Bauer.
!
      SUBROUTINE SADVAN2(MICALL)
!
      USE PRSIZES,       ONLY: ISIZE,MAXRECID
!
      USE PR_BAYES_INT2, ONLY: SISFINL
!
      USE PR_BAYES_REAL2,ONLY: SA,STSTATE,SDAETA,SD2AETA
!
!
! INTEGER
      USE NMPRD_INT,     ONLY: IQUIT
      USE PRCOM_INT,     ONLY: NC,XNPETA,ADVID
      USE PROCM_INT,     ONLY: ISFINL
      USE NM_BAYES_INT,  ONLY: ISADVAN2,ISADVAN2_REC
      USE NMBAYES_INT,   ONLY: JIND
! LOGICAL
      USE PRCOM_LOG,     ONLY: SECOND,DTIME,LFLAG,DTDER,DTSTART,DTEND
      USE PR_BAYES_LOG,  ONLY: SDTIME,SDTDER,SLFLAG
! REAL
      USE PROCM_REAL,    ONLY: AMNT,DAETA,D2AETA,TSTATE
      USE PRCOM_REAL,    ONLY: TSTART
! INTERFACE
      USE PR_INTERFACE,  ONLY: SADVAN
      USE NM_INTERFACE,  ONLY: ERRORMSGS
!
      IMPLICIT NONE
!
      INTEGER(KIND=ISIZE), INTENT(IN) :: MICALL
!
!
!------------------------------------------------------------------------------------
!
! Local Variables
!
      INTEGER(KIND=ISIZE) :: I,J,K
!
      SAVE
!
      IF (ISADVAN2_REC > MAXRECID .AND. (ADVID==16.OR.ADVID==17.OR.ADVID==18)) THEN
        CALL ERRORMSGS(508)
      ENDIF
      IF (ISADVAN2 == 0 .OR. ISADVAN2_REC > MAXRECID) THEN
        CALL SADVAN(MICALL,0) !7.2b52b
        IF (IQUIT == 1) GO TO 999
        IF (ISADVAN2_REC <= MAXRECID .AND. ISADVAN2_REC > 0) THEN
          DO I=1,NC
            SA(I,ISADVAN2_REC)=AMNT(I)
            DO J=1,XNPETA
              SDAETA(I,J,ISADVAN2_REC)=DAETA(I,J)
              IF (SECOND) THEN
                DO K=J,XNPETA
                  SD2AETA(I,K,J,ISADVAN2_REC)=D2AETA(I,K,J)
                END DO
              END IF
            END DO
          END DO
          STSTATE(ISADVAN2_REC)=TSTATE
          SDTIME(ISADVAN2_REC)=DTIME
          SDTDER(ISADVAN2_REC)=DTDER
          SLFLAG(ISADVAN2_REC)=LFLAG
          SISFINL(ISADVAN2_REC)=ISFINL
        END IF
      ELSE
        IF (ISADVAN2_REC <= MAXRECID .AND. ISADVAN2_REC > 0) THEN
!7.2b52b.  SADVAN called not to call ADVAN, which is expensive, but to update variables
          CALL SADVAN(MICALL,1)
          IF (IQUIT == 1) GO TO 999
          DO I=1,NC
            AMNT(I)=SA(I,ISADVAN2_REC)
            DO J=1,XNPETA
              DAETA(I,J)=SDAETA(I,J,ISADVAN2_REC)
              IF (SECOND) THEN
                DO K=J,XNPETA
                  D2AETA(I,K,J)=SD2AETA(I,K,J,ISADVAN2_REC)
                END DO
              END IF
            END DO
          END DO
          TSTATE=STSTATE(ISADVAN2_REC)
          DTIME=SDTIME(ISADVAN2_REC)
          DTDER=SDTDER(ISADVAN2_REC)
          LFLAG=SLFLAG(ISADVAN2_REC)
          ISFINL=SISFINL(ISADVAN2_REC)
        END IF
      END IF
!
  999 RETURN
!
      END SUBROUTINE SADVAN2
!
!-----------------------------HISTORY------------------------------------------------
! VERSION     : NONMEM VII
! AUTHOR      : ROBERT J. BAUER
! CREATED ON  : MAR/2010
! LANGUAGE    : FORTRAN 90/95
! LAST UPDATE : MAR/2010 - INTRODUCED HEADER INFORMATIONS AND RESTRUCTURED AS PER
!                          THE NONMEM STANDARDS
!               AUG/2012 - INTEGRATED NONMEM7.3ALPHA6.3 CHANGES
!               OCT/2012 - INTEGRATED NONMEM7.3BETA5.0 CHANGES
!
!-------------------------------- EVENT_REPEAT.F90 ----------------------------------
!
! FUNCTION EVENT_REPEAT(IMODE,NEVENT,ICALL)
!
! DESCRIPTION : Updates value of EVENT_REPEAT, IXCOUNT, EVTREC.
!
! ARGUMENTS   : IMODE,NEVENT,ICALL
!
!               IN  - IMODE,NEVENT,ICALL
!               IN     - IMODE,NEVENT,ICALL
!                              IMODE  - Flag = 0,1,2
!                              NEVENT - Number of logical records in an event record
!                              ICALL  - Values from 0 to 6
!               OUT    - NONE
!               IN OUT - NONE
!
! CALLED BY   : PRED
!
! CALLS       : NONE
!
! ALGORITHM   : - Initialize EVENT_REPEAT to 0.
!               - If IMODE equals 0, set IXCOUNT to 1 and return.
!               - If IMODE equals 2:
!                 - Increment IXCOUNT
!                 - Return if the following conditions are true: IXCOUNT is
!                   greater than NXVID or XVID(IXCOUNT) equals 0 or
!                   EVTREC(NEVENT,XVID(IXCOUNT)) is less than 0
!                 - Set EVENT_REPEAT to 1 and return
!               - Return if any of the conditions are true
!               - Update EVTREC and return.
!
! MODULES USED: PRSIZES,SIZES,PRCOM_INT,NMPRD_INT,PROCM_REAL
!
! CONTAINS    : NONE
!
! LOCALS      : EVENT_REPEAT
!
!---------------------------- END OF HEADER -----------------------------------------
!
      FUNCTION EVENT_REPEAT(IMODE,NEVENT,ICALL)
!
      USE PRSIZES,      ONLY: ISIZE
!
!
! INTEGER
      USE PRCOM_INT,    ONLY: JEVENT
      USE NMPRD_INT,    ONLY: IDXMDV,XVID,IXCOUNT,NXVID
! REAL
      USE PROCM_REAL,   ONLY: EVTREC
!
      IMPLICIT NONE
!
      INTEGER(KIND=ISIZE), INTENT(IN) :: IMODE,NEVENT,ICALL
!
!
!------------------------------------------------------------------------------------
!
! Local Variables
!
      INTEGER(KIND=ISIZE) :: EVENT_REPEAT
!
!      INTEGER (KIND=ISIZE), PARAMETER :: NXVID=5
!      INTEGER (KIND=ISIZE) :: XVID(NXVID),IXCOUNT
! Moved COMMON statement to Global.f90 under the module NMPRD_INT
!      COMMON /EVENT_REPEAT_COMMON/ XVID,IXCOUNT
      EVENT_REPEAT=0
!
      IF (ICALL == 4) GO TO 999
      IF (IMODE == 0) THEN
        IXCOUNT=1
        GO TO 999
      END IF
!
      IF (IMODE == 2) THEN
        IXCOUNT=IXCOUNT+1
        IF (IXCOUNT > NXVID) GO TO 999
        IF (XVID(IXCOUNT) == 0) GO TO 999
        IF (NEVENT < 1 .OR. NEVENT > 5) GO TO 999
        IF (EVTREC(NEVENT,XVID(IXCOUNT)) < 0) GO TO 999
        EVENT_REPEAT=1
        GO TO 999
      END IF
!
      IF (IXCOUNT <= 0 .OR. IXCOUNT > NXVID) GO TO 999
      IF (XVID(IXCOUNT) == 0) GO TO 999
      IF (NEVENT < 1 .OR. NEVENT > 5) GO TO 999
      IF (EVTREC(NEVENT,XVID(IXCOUNT)) < 0) GO TO 999
      EVTREC(NEVENT,JEVENT)=EVTREC(NEVENT,XVID(IXCOUNT))
      IF (EVTREC(NEVENT,JEVENT) /= 0) EVTREC(NEVENT,IDXMDV)=1
!
  999 RETURN
!
      END FUNCTION EVENT_REPEAT
!
!-----------------------------HISTORY------------------------------------------------
! VERSION     : NONMEM VII
! AUTHOR      : ROBERT J. BAUER
! CREATED ON  : APR/2019
! LANGUAGE    : FORTRAN 90/95
! LAST UPDATE : APR/2019 - INTRODUCED HEADER INFORMATIONS AND RESTRUCTURED AS PER
!                          THE NONMEM STANDARDS
!
!---------------------------- PRED_TIMEVALUES_INFO.F90 ------------------------------
!
! SUBROUTINE PRED_TIMEVALUES_INFO()
!
! DESCRIPTION : Obtain initial time ranges to facilitate DDE solvers
!
!
! ARGUMENTS   : NONE
!               IN     - NONE
!               OUT    - NONE
!               IN OUT - NONE
!
! CALLED BY   : PRED
!
! CALLS       : DAT1,DAT3
!
! ALGORITHM   : See description
!
! MODULES USED: FSIZES,PRSIZES,PR_BAYES_REAL2,PR_BAYES_INT2,SIZES,PRCOM_INT,
!               CMNM2_INT,NM_BAYES_INT,NMPRD_INT,CMNM1_INT,CMNM1_REAL
!
! CONTAINS    : NONE
!
! LOCALS      : I,IEVENT,IEVENTPREV,JPREV,J,JJPREV,IZZ,JJPREV2,JJ,TIMEPREV
!
!---------------------------- END OF HEADER -----------------------------------------
!
!

      SUBROUTINE PRED_TIMEVALUES_INFO()
!
      USE FSIZES,        ONLY: F_PC,F_PG,F_LVO,F_LVS
!
      USE PRSIZES,       ONLY: ISIZE,DPSIZE,PC,PE,MAXRECID
!
      USE PR_BAYES_REAL2
!
      USE PR_BAYES_INT2
!
!
! INTEGER
      USE PRCOM_INT,     ONLY: ADVID,JAMT,JCOMPF,JCOMPT,JCONT,JDELTA,JDUM,JERROR,    &
                               JEVENT,JMORE,JRATE,JSS,JTIME
      USE CMNM2_INT,     ONLY: NRECIND,IRECIDX
      USE NM_BAYES_INT,  ONLY: DATNN_PREV,DATNN_PREVM
      USE NMPRD_INT,     ONLY: IPS
      USE CMNM1_INT,     ONLY: NIND
! REAL
      USE CMNM1_REAL,    ONLY: VDATREC
!
      IMPLICIT NONE
!
!
!
!------------------------------------------------------------------------------------
!
! Local Variables
!
      INTEGER(KIND=ISIZE) :: I,IEVENT,IEVENTPREV,JPREV,J,JJPREV,IZZ,JJPREV2,JJ
      REAL(KIND=DPSIZE) :: TIMEPREV
!
      SAVE
!
      IF(IPS/=2) THEN
        PRED_NTIMEVALUES=0
        IEVENTPREV=-1
        TIMEPREV=-1.0D+300
        JPREV=DATNN_PREV(1)
        DO I=1,NRECIND                ! Loop over number of individual records
          CALL DAT1(IRECIDX+I,0,0)    ! Holds and handles number of contiguous data records.
          IEVENT=VDATREC(JEVENT)
          IF((IEVENT==3.OR.IEVENT==4).AND.I/=1.AND.IEVENTPREV/=3.AND.IEVENTPREV/=4) THEN
            PRED_NTIMEVALUES=PRED_NTIMEVALUES+1
            PRED_TIMEVALUE(PRED_NTIMEVALUES)=TIMEPREV
            PRED_TIMETYPE(PRED_NTIMEVALUES)=2
          ENDIF
          IF(I==1.OR.IEVENT==3.OR.IEVENT==4) THEN
            PRED_NTIMEVALUES=PRED_NTIMEVALUES+1
            PRED_TIMEVALUE(PRED_NTIMEVALUES)=VDATREC(JTIME)
            PRED_TIMETYPE(PRED_NTIMEVALUES)=1
          ENDIF
          IF(I==NRECIND) THEN
            PRED_NTIMEVALUES=PRED_NTIMEVALUES+1
            PRED_TIMEVALUE(PRED_NTIMEVALUES)=VDATREC(JTIME)
            PRED_TIMETYPE(PRED_NTIMEVALUES)=2
          ENDIF
          IEVENTPREV=IEVENT
          TIMEPREV=VDATREC(JTIME)
        END DO
        CALL DAT1(JPREV,0,0)       ! RESTORE ORIGINAL LOCATION
      ELSE ! SINGLE SUBJECT
        JJPREV=DATNN_PREV(3)
        IF(JJPREV/=1) GO TO 998
        PRED_NTIMEVALUES=0
        IEVENTPREV=-1
        TIMEPREV=-1.0D+300
        JPREV=DATNN_PREV(1)
        CALL DAT3(0,0,0)
        IZZ=0
        DO JJ=1,NIND
          CALL DAT3 (JJ,0,0)                     ! Get individual record header
          DO I=1,NRECIND                ! Loop over number of individual records
            IZZ=IZZ+1
            CALL DAT1(IRECIDX+I,0,0)    ! Holds and handles number of contiguous data records.
            IEVENT=VDATREC(JEVENT)
            IF((IEVENT==3.OR.IEVENT==4).AND.IZZ/=1.AND.IEVENTPREV/=3.AND.IEVENTPREV/=4) THEN
              PRED_NTIMEVALUES=PRED_NTIMEVALUES+1
              PRED_TIMEVALUE(PRED_NTIMEVALUES)=TIMEPREV
              PRED_TIMETYPE(PRED_NTIMEVALUES)=2
            ENDIF
            IF(IZZ==1.OR.IEVENT==3.OR.IEVENT==4) THEN
              PRED_NTIMEVALUES=PRED_NTIMEVALUES+1
              PRED_TIMEVALUE(PRED_NTIMEVALUES)=VDATREC(JTIME)
              PRED_TIMETYPE(PRED_NTIMEVALUES)=1
            ENDIF
            IF(I==NRECIND.AND.JJ==NIND) THEN
              PRED_NTIMEVALUES=PRED_NTIMEVALUES+1
              PRED_TIMEVALUE(PRED_NTIMEVALUES)=VDATREC(JTIME)
              PRED_TIMETYPE(PRED_NTIMEVALUES)=2
            ENDIF
            IEVENTPREV=IEVENT
            TIMEPREV=VDATREC(JTIME)
          END DO
        ENDDO
! RESTORE ORIGINAL LOCATION
        CALL DAT3(0,0,0)
        CALL DAT1(0,0,0)
        CALL DAT3(JJPREV,0,0)
        CALL DAT1(JPREV,0,0)
      ENDIF
  998 CONTINUE
!
  999 RETURN
!
      END SUBROUTINE PRED_TIMEVALUES_INFO


!
!-----------------------------HISTORY------------------------------------------------
! VERSION     : NONMEM VII
! AUTHOR      : ROBERT J. BAUER
! CREATED ON  : APR/2019
! LANGUAGE    : FORTRAN 90/95
! LAST UPDATE : APR/2019 - INTRODUCED HEADER INFORMATIONS AND RESTRUCTURED AS PER
!                          THE NONMEM STANDARDS
!
!---------------------------------- STATE_MAP.F90 -----------------------------------
!
! SUBROUTINE STATE_MAP(ICMT,IPP,NNS,DVALS,NVALS)
!
! DESCRIPTION : GET MAPPING INFORMATION OF TIME DELAY DERIVATIVE STATES
!
!
! ARGUMENTS   : ICMT,IPP,NNS,DVALS,NVALS
!               IN     - ICMT,IPP
!               OUT    - NNS,DVALS,NVALS
!               IN OUT - NONE
! Arguments are best explained under ALGORITHM
!
!
! CALLED BY   : DDEFUNC
!
! CALLS       : GG,ERRORMSGS
!
! ALGORITHM   : 
!               Given Compartment ICMT, and parameter IPP, Get vector of NVALS derivatives:
!               For all Derivative of Parameter IPP wrt ETA(K) that is not 0,
!               DVALS(I)=Derivative of parameter IPP wrt eta(k), for which DADT(ICMTS(I))=derivative of A(ICMT) wrt Eta(k)
!
! MODULES USED: PRSIZES,SIZES,NMPRD_INT,PRCM_INT,PRCOM_INT,PROCM_INT,PRCM_LOG,
!               PRCOM_LOG,PRCM_REAL,PRCOM_REAL,NM_INTERFACE
!
! CONTAINS    : NONE
!
! LOCALS      : PM=PC-1,AXI,I,IP,IXI,J,JJ,JJY,K,L,LL,LLY,TXI,G2,TEMP
!
!---------------------------- END OF HEADER -----------------------------------------
!

      SUBROUTINE STATE_MAP(ICMT,IPP,NNS,DVALS,NVALS)
!
      USE PRSIZES,      ONLY: ISIZE,DPSIZE
!
!
! INTEGER
      USE PRCM_INT,     ONLY: LEND,LST,MAP
      USE PRCOM_INT,    ONLY: NCM1,ADVID,NPETAS,XNPETA
      USE PROCM_INT,    ONLY: IDXETAI

      USE PRCM_LOG,     ONLY: COMPAC,MAPPED
!
      IMPLICIT NONE
!
      INTEGER(KIND=ISIZE), INTENT(IN)     :: IPP,ICMT
      INTEGER(KIND=ISIZE), INTENT(OUT) :: NNS(*),NVALS
      REAL(KIND=DPSIZE), INTENT(OUT) :: DVALS(*)
      INTEGER(KIND=ISIZE) :: I,J,K
!
!
!------------------------------------------------------------------------------------
!
! Local Variables
!
      INTEGER(KIND=ISIZE) :: LSTZ,LENDZ
!
      SAVE
!

       I=ICMT

 990  CONTINUE
      NVALS=0
      J=IDXETAI(IPP)
      IF(J<=0) GO TO 999
      NVALS=1
      NNS(NVALS)=I+J*NCM1
      DVALS(NVALS)=1.0D+00


  999 RETURN
!
      END SUBROUTINE STATE_MAP
